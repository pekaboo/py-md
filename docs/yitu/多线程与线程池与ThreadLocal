


## 27. 项目中的异步编排

### 要点速览 · 27

- 常见方案：消息队列、`CompletableFuture`、调度编排框架。
- 核心关注点：任务依赖、失败补偿、可观测性。
- 保证幂等与重试机制。

### 基础要点 · 27

- 使用 MQ（Kafka/RabbitMQ）实现解耦，消费者异步处理耗时任务。
- 应用内用线程池+`CompletableFuture`/`@Async` 并行查询。
- 调度系统（xxl-job/Quartz）处理定时任务链。

### 进阶扩展 · 27

- 落地时定义编排 DAG，利用工作流引擎（Camunda、Airflow）处理复杂依赖。
- 结合事件总线与 Saga/TCC 实现跨服务补偿。
- 通过链路追踪、埋点监控异步任务耗时、成功率。

### ⚠️注意事项 · 27

- 控制线程池、消费者速率，避免洪峰拖垮下游。
- 幂等键设计（主键、业务唯一标识）防止重复消费。
- 异步失败需有告警与手动补偿渠道。

## 28. ThreadLocal 在异步多线程环境

### 要点速览 · 28

- ThreadLocal 默认仅限当前线程，异步线程无法继承。
- 线程池复用导致脏数据、内存泄漏。
- 解决：显式传递上下文或使用装饰器。

### 基础要点 · 28

- 线程切换时 ThreadLocal 值不会自动传播。
- 线程池中的线程复用旧值，若未 `remove` 会污染新任务。
- 异步回调需在执行前设值，执行后清理。

### 进阶扩展 · 28

- 使用 `TransmittableThreadLocal`（TTL）配合线程池自动传递上下文。
- Spring `TaskDecorator`、`MdcTaskDecorator` 可封装上下文复制与清理。
- Reactor/Sleuth 提供上下文传播 API（`Context`、`Hook`）。

### ⚠️注意事项 · 28

- 控制 ThreadLocal 储存对象大小，避免 OOM。
- 尽量使用不可变对象或快照，减少并发修改。
- 上下文传递需考虑安全与隐私，避免越权。

## 29. ThreadLocal 使用流程需注意事项

### 要点速览 · 29

- 明确生命周期：初始化、使用、清理。
- 遵循安全发布与访问模式。
- 配合监控及时发现泄漏。

### 基础要点 · 29

- 创建 ThreadLocal 时提供初始值供应器（`withInitial`）。
- 使用完毕执行 `remove`，尤其在线程池场景。
- 值对象需线程封闭，不共享可变引用。

### 进阶扩展 · 29

- 建立统一封装（如 `ThreadLocalContext`）管理 set/remove，提高可维护性。
- 日志 MDC 结合 ThreadLocal，需在过滤器/拦截器中集中清理。
- 配合诊断工具监控 `ThreadLocalMap` 占用，可定期 dump 分析。

### ⚠️注意事项 · 29

- 禁止在 ThreadLocal 存放连接等可复用资源，易造成泄漏。
- 建议配合 try-finally 模式，确保异常情况下也清理。
- 对关键上下文需提供 fallback（如默认租户），防止缺失导致 NPE。
