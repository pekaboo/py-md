# MyBatis 中 #{} 和 ${} 的区别是什么？

**难度**：简单

**创建时间**：2025-10-06 15:36:08

## 答案
在 MyBatis 中，`#{}` 和 `${}` 是两种不同的参数占位符，它们的核心区别在于 **参数处理方式** 和 **安全性**。以下是详细对比：

---

### **1. `#{}`（预编译占位符）**
- **处理方式**：  
  MyBatis 会将 `#{}` 替换为 `?`，然后通过 **JDBC 预编译（PreparedStatement）** 设置参数值。  
  **示例**：  
  ```sql
  SELECT * FROM user WHERE id = #{id}
  ```  
  预编译后实际执行的 SQL：  
  ```sql
  SELECT * FROM user WHERE id = ?
  ```  
  参数值（如 `id=1`）会通过安全的方式绑定到 `?`。

- **特点**：
  - **防 SQL 注入**：参数值会被转义（如字符串加引号），避免恶意 SQL 拼接。
  - **支持自动类型转换**：Java 类型（如 `Integer`、`Date`）可自动映射到数据库类型。
  - **性能优化**：数据库会缓存预编译的 SQL 执行计划。

- **适用场景**：  
  所有需要安全传参的地方（如 WHERE 条件、INSERT/UPDATE 值）。

---

### **2. `${}`（字符串替换占位符）**
- **处理方式**：  
  MyBatis 会直接将 `${}` 替换为参数的 **原始字符串值**（不做任何处理），拼接到 SQL 中。  
  **示例**：  
  ```sql
  SELECT * FROM user WHERE name = '${name}'
  ```  
  若 `name=John`，拼接后的 SQL：  
  ```sql
  SELECT * FROM user WHERE name = 'John'
  ```

- **特点**：
  - **存在 SQL 注入风险**：如果参数来自用户输入且未过滤，可能被注入恶意 SQL。
  - **无类型转换**：参数值直接按原样拼接（如字符串需手动加引号）。
  - **动态表名/列名**：适合非值替换的场景（如表名、排序字段）。
- **适用场景**：  
  需要动态拼接 SQL 片段时（如动态表名、排序字段、列名），例如：  
  ```sql
  SELECT * FROM ${tableName} ORDER BY ${columnName}
  ```

---

### **3. 核心区别总结**
| **特性**               | `#{}`                          | `${}`                          |
|------------------------|--------------------------------|--------------------------------|
| **处理方式**           | 预编译参数绑定（?）            | 字符串直接替换                 |
| **安全性**             | 防 SQL 注入                    | **不防 SQL 注入**             |
| **类型转换**           | 自动处理                       | 需手动处理（如字符串加引号）   |
| **适用场景**           | 值替换（WHERE/INSERT/UPDATE）  | SQL 片段动态拼接（表名/列名）  |
| **性能**               | 支持预编译优化                 | 每次需重新解析 SQL            |

---

### **4. 实际示例对比**
#### **场景 1：安全查询（使用 `#{}`）**
```xml
<!-- 安全：参数会被预编译 -->
<select id="getUserById" resultType="User">
    SELECT * FROM user WHERE id = #{id}
</select>
```

#### **场景 2：动态表名（使用 `${}`）**
```xml
<!-- 动态表名必须用 ${}，但需确保参数可信 -->
<select id="getUsersFromTable" resultType="User">
    SELECT * FROM ${tableName} WHERE status = 1
</select>
```

#### **场景 3：错误用法（导致 SQL 注入）**
```xml
<!-- 危险！若 name 参数为 "1' OR '1'='1"，会导致全表查询 -->
<select id="getUserByNameUnsafe" resultType="User">
    SELECT * FROM user WHERE name = '${name}'
</select>
```

---

### **5. 最佳实践**
1. **优先使用 `#{}`**：除非有明确的动态 SQL 拼接需求，否则始终用 `#{}` 保证安全性。
2. **慎用 `${}`**：仅用于不可变的部分（如表名、排序字段），且需对参数值严格校验。
3. **日志调试**：开启 MyBatis 日志（`logImpl=STDOUT_LOGGING`）观察实际执行的 SQL。

---

### **总结**
- `#{}` 是安全的参数绑定，适合值替换。  
- `${}` 是直接的字符串替换，适合动态 SQL 片段，但需防范注入风险。  
- 错误的占位符选择可能导致功能异常或安全漏洞。
