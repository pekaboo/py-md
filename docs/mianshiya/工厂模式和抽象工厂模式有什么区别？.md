# 工厂模式和抽象工厂模式有什么区别？

**难度**：中等

**创建时间**：2025-10-06 05:58:08

## 答案
工厂模式（Factory Method Pattern）和抽象工厂模式（Abstract Factory Pattern）都是**创建型设计模式**，用于管理对象的创建，但它们的适用场景、结构和扩展性有显著区别。以下是两者的详细对比：

---

### **1. 核心目的**
- **工厂模式（工厂方法）**：
  - **定义一个创建对象的接口**，但由子类决定实例化哪个类。
  - **延迟实例化**：将对象的创建推迟到子类中完成。
  - **解决单一产品的创建问题**，例如根据不同条件创建同一种产品的不同子类。

- **抽象工厂模式**：
  - **创建相关或依赖对象的家族**，而无需指定它们的具体类。
  - **解决产品族的创建问题**，例如同时创建一套相关的产品（如UI组件的按钮、文本框、菜单等）。

---

### **2. 结构对比**
#### **工厂模式（工厂方法）**
- **角色**：
  1. **抽象产品（Product）**：定义产品的接口。
  2. **具体产品（Concrete Product）**：实现抽象产品接口的具体类。
  3. **抽象创建者（Creator）**：声明工厂方法，返回一个产品对象。
  4. **具体创建者（Concrete Creator）**：重写工厂方法，返回具体产品实例。

- **特点**：
  - 每个具体创建者对应一个具体产品。
  - 通过继承实现扩展（子类决定创建哪个产品）。

- **代码示例（Java）**：
  ```java
  // 抽象产品
  interface Button {
      void render();
  }

  // 具体产品
  class WindowsButton implements Button {
      @Override
      public void render() {
          System.out.println("渲染Windows风格按钮");
      }
  }

  class MacButton implements Button {
      @Override
      public void render() {
          System.out.println("渲染Mac风格按钮");
      }
  }

  // 抽象创建者
  abstract class GUIFactory {
      abstract Button createButton();
  }

  // 具体创建者
  class WindowsFactory extends GUIFactory {
      @Override
      Button createButton() {
          return new WindowsButton();
      }
  }

  class MacFactory extends GUIFactory {
      @Override
      Button createButton() {
          return new MacButton();
      }
  }

  // 客户端使用
  public class Client {
      public static void main(String[] args) {
          GUIFactory factory = new WindowsFactory(); // 可替换为MacFactory
          Button button = factory.createButton();
          button.render(); // 输出: 渲染Windows风格按钮
      }
  }
  ```

#### **抽象工厂模式**
- **角色**：
  1. **抽象工厂（Abstract Factory）**：定义创建一系列产品的接口。
  2. **具体工厂（Concrete Factory）**：实现抽象工厂接口，创建具体产品族。
  3. **抽象产品（Abstract Product）**：定义每个产品的接口。
  4. **具体产品（Concrete Product）**：实现抽象产品接口的具体类。

- **特点**：
  - 每个具体工厂创建一套相关产品（产品族）。
  - 通过替换具体工厂实现整体风格的切换（如从Windows UI切换到Mac UI）。

- **代码示例（Java）**：
  ```java
  // 抽象产品1
  interface Button {
      void render();
  }

  // 抽象产品2
  interface Checkbox {
      void check();
  }

  // 具体产品1（Windows系列）
  class WindowsButton implements Button {
      @Override
      public void render() {
          System.out.println("渲染Windows风格按钮");
      }
  }

  class WindowsCheckbox implements Checkbox {
      @Override
      public void check() {
          System.out.println("勾选Windows风格复选框");
      }
  }

  // 具体产品2（Mac系列）
  class MacButton implements Button {
      @Override
      public void render() {
          System.out.println("渲染Mac风格按钮");
      }
  }

  class MacCheckbox implements Checkbox {
      @Override
      public void check() {
          System.out.println("勾选Mac风格复选框");
      }
  }

  // 抽象工厂
  interface GUIFactory {
      Button createButton();
      Checkbox createCheckbox();
  }

  // 具体工厂1（Windows工厂）
  class WindowsFactory implements GUIFactory {
      @Override
      public Button createButton() {
          return new WindowsButton();
      }

      @Override
      public Checkbox createCheckbox() {
          return new WindowsCheckbox();
      }
  }

  // 具体工厂2（Mac工厂）
  class MacFactory implements GUIFactory {
      @Override
      public Button createButton() {
          return new MacButton();
      }

      @Override
      public Checkbox createCheckbox() {
          return new MacCheckbox();
      }
  }

  // 客户端使用
  public class Client {
      public static void main(String[] args) {
          GUIFactory factory = new WindowsFactory(); // 可替换为MacFactory
          Button button = factory.createButton();
          Checkbox checkbox = factory.createCheckbox();
          button.render();    // 输出: 渲染Windows风格按钮
          checkbox.check();   // 输出: 勾选Windows风格复选框
      }
  }
  ```

---

### **3. 关键区别**
| **维度**               | **工厂模式（工厂方法）**                     | **抽象工厂模式**                           |
|------------------------|--------------------------------------------|--------------------------------------------|
| **目的**               | 创建单一产品                               | 创建产品族（一组相关产品）                 |
| **扩展方式**           | 通过继承（子类决定创建哪个产品）           | 通过新增具体工厂（无需修改现有代码）       |
| **产品数量**           | 每次只创建一个产品                         | 每次创建一组相关产品                       |
| **客户端代码**         | 依赖抽象创建者（Creator）                  | 依赖抽象工厂（Abstract Factory）           |
| **开闭原则支持**       | 较好（新增产品需新增子类）                 | 更好（新增产品族只需新增具体工厂）         |
| **复杂度**             | 较低                                       | 较高（需管理多个产品的接口）               |

---

### **4. 适用场景**
#### **工厂模式（工厂方法）**
- 当系统需要**灵活创建单一产品**时，例如：
  - 根据用户输入或配置文件动态创建对象。
  - 需要将对象的创建与使用解耦。
  - 例如：日志框架（根据配置创建文件日志或数据库日志）。

#### **抽象工厂模式**
- 当系统需要**创建一组相关或依赖的对象**时，例如：
  - 跨平台UI工具包（同时创建按钮、文本框、菜单等，且风格一致）。
  - 游戏开发中创建不同风格的敌人（同时创建地面单位、空中单位等）。
  - 例如：Android和iOS的UI组件库切换。

---

### **5. 优缺点对比**
#### **工厂模式（工厂方法）**
- **优点**：
  - 符合开闭原则（新增产品只需新增子类）。
  - 客户端与具体产品解耦。
- **缺点**：
  - 每个产品需要一个对应的子类，可能导致类数量爆炸。

#### **抽象工厂模式**
- **优点**：
  - 易于交换产品族（通过替换具体工厂）。
  - 保证创建的产品相互兼容（如UI风格一致）。
- **缺点**：
  - 新增产品时需修改抽象工厂接口和所有具体工厂（违反开闭原则）。
  - 结构复杂，学习成本较高。

---

### **6. 实际应用案例**
#### **工厂模式（工厂方法）**
- **Java的`Collection.iterator()`**：
  - 每个集合类（如`ArrayList`、`HashSet`）通过子类实现自己的迭代器。
- **Spring的`BeanFactory`**：
  - 子类（如`XmlBeanFactory`）决定如何创建Bean。

#### **抽象工厂模式**
- **跨平台UI框架**：
  - 如Java的`Swing`（通过`LookAndFeel`切换整体风格）。
- **数据库驱动**：
  - 不同数据库厂商提供各自的驱动实现（如MySQL、Oracle的驱动工厂）。
- **汽车制造**：
  - 具体工厂（如“丰田工厂”）创建发动机、轮胎、车身等配套产品。

---

### **7. 总结**
- **工厂模式（工厂方法）**：
  - 适合**单一产品**的创建，通过子类化实现扩展。
  - 例如：根据用户选择创建不同类型的日志记录器。

- **抽象工厂模式**：
  - 适合**产品族**的创建，保证产品间的兼容性。
  - 例如：切换整个应用的UI风格（从Windows到Mac）。

**选择建议**：
- 如果只需创建独立对象，用**工厂方法**。
- 如果需要创建一组相互依赖的对象，用**抽象工厂**。
