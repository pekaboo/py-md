# Redis 数据过期后的删除策略是什么？

**难度**：中等

**创建时间**：2025-10-06 15:39:12

## 答案
Redis 数据过期后的删除策略是其内存管理的核心机制之一，直接影响内存利用率和系统性能。Redis 采用了**惰性删除（Lazy Expiration）**和**定期删除（Periodic Expiration）**相结合的混合策略，并配合内存淘汰策略（Eviction Policy）处理未及时删除的过期键，确保内存高效使用。以下是详细解析：

---

### **一、Redis 过期键的删除策略**
#### **1. 惰性删除（Lazy Expiration）**
- **原理**：仅在访问键时检查是否过期，若过期则立即删除。
- **触发场景**：
  - 执行 `GET`、`SET` 等命令时，检查键的过期时间。
  - 例如：`GET expired_key` 若键已过期，则返回 `nil` 并删除键。
- **优点**：
  - 无额外开销，仅在访问时处理。
  - 避免集中删除导致的性能抖动。
- **缺点**：
  - 若过期键长期未被访问，会持续占用内存（如冷数据）。

#### **2. 定期删除（Periodic Expiration）**
- **原理**：Redis 每隔一定时间（默认每秒 10 次）随机抽取部分过期键进行删除。
- **实现细节**：
  - **采样频率**：通过 `hz` 参数配置（默认 10，即每秒 10 次检查）。
  - **采样数量**：每次随机检查约 20 个键（可配置 `active-expire-effort` 调整）。
  - **删除逻辑**：
    1. 遍历抽中的键，若过期则删除。
    2. 若本轮删除的键占比超过 25%，则重复抽样检查（避免漏删）。
- **优点**：
  - 主动清理过期键，减少内存浪费。
  - 通过随机采样避免全量扫描的性能开销。
- **缺点**：
  - 无法保证所有过期键被及时删除（依赖采样概率）。

#### **3. 内存淘汰策略（Eviction Policy）**
- **作用**：当内存不足且未设置 `maxmemory` 时，Redis 不会主动淘汰；若设置了 `maxmemory`，则根据淘汰策略删除键（包括过期键）。
- **常见策略**：
  - **volatile-lru**：淘汰最近最少使用的过期键。
  - **volatile-ttl**：淘汰即将过期的键（TTL 最小的）。
  - **allkeys-lru**：淘汰所有键中最近最少使用的（包括未过期的）。
  - **noeviction**（默认）：内存不足时返回错误，不删除键。
- **触发条件**：
  - 内存使用达到 `maxmemory` 阈值。
  - 执行写入命令（如 `SET`）时触发淘汰。

---

### **二、Redis 过期键的底层实现**
#### **1. 过期时间存储**
- Redis 使用**字典（Hash 表）**存储键的过期时间，键为原始键名，值为过期时间戳（Unix 时间戳）。
- 示例：
  ```c
  typedef struct redisDb {
      dict *dict;         // 键空间（存储所有键值对）
      dict *expires;      // 过期字典（存储键的过期时间）
  } redisDb;
  ```

#### **2. 过期时间设置**
- 通过 `EXPIRE`、`EXPIREAT`、`PEXPIRE` 等命令设置过期时间：
  ```bash
  EXPIRE mykey 60       # 60 秒后过期
  EXPIREAT mykey 1633046400  # 指定时间戳过期
  ```
- 内部将时间转换为毫秒级存储（PEXPIRE 系列）。

#### **3. 持久化中的过期处理**
- **RDB 持久化**：
  - 生成 RDB 文件时，不保存已过期的键。
  - 加载 RDB 时，若键在文件中但已过期，则不会加载。
- **AOF 持久化**：
  - 写入 AOF 文件时，若键过期，会追加 `DEL` 命令。
  - AOF 重写时，忽略已过期的键。

---

### **三、策略选择与调优建议**
#### **1. 默认策略的适用场景**
- **惰性删除 + 定期删除**：适合大多数场景，平衡性能和内存。
- **内存淘汰策略**：需根据业务需求选择：
  - 优先保留热点数据：`volatile-lru` 或 `allkeys-lru`。
  - 避免删除未过期键：`volatile-ttl`。

#### **2. 性能优化参数**
- **`hz` 参数**：调整定期删除的检查频率（默认 10，范围 1-500）。
  - 增大 `hz`：更频繁清理过期键，但增加 CPU 开销。
  - 减小 `hz`：减少 CPU 使用，但可能延迟过期键删除。
  ```bash
  # 配置文件或启动参数
  hz 10
  ```
- **`active-expire-effort`**：控制定期删除的采样强度（默认 1，范围 1-10）。
  - 增大值：更彻底清理，但增加 CPU 负载。

#### **3. 监控过期键**
- **`INFO stats`**：查看 `expired_keys` 统计（累计删除的过期键数）。
  ```bash
  redis-cli INFO stats | grep expired_keys
  ```
- **`INFO keyspace`**：查看各数据库的键统计（包括过期键）。

---

### **四、常见问题与解决方案**
#### **1. 问题：过期键未及时删除导致内存溢出**
- **原因**：
  - 惰性删除未触发（冷数据未被访问）。
  - 定期删除采样未覆盖到过期键。
- **解决方案**：
  - 调整 `hz` 和 `active-expire-effort`。
  - 设置合理的 `maxmemory` 和淘汰策略（如 `volatile-lru`）。

#### **2. 问题：大量键同时过期导致性能抖动**
- **原因**：定期删除集中处理大量过期键。
- **解决方案**：
  - 避免集中设置相同过期时间（如使用随机偏移量）。
  - 示例：
    ```bash
    # 错误：所有键同时过期
    EXPIRE key1 60
    EXPIRE key2 60

    # 正确：随机偏移过期时间
    EXPIRE key1 $((60 + RANDOM % 30))
    EXPIRE key2 $((60 + RANDOM % 30))
    ```

#### **3. 问题：持久化文件中包含过期键**
- **原因**：RDB/AOF 生成时未正确过滤过期键。
- **解决方案**：
  - 确保 Redis 版本支持持久化时的过期键过滤（Redis 2.4+）。
  - 定期执行 `BGSAVE` 或 `BGREWRITEAOF` 清理数据。

---

### **五、总结**
| **策略**               | **触发时机**               | **优点**                          | **缺点**                          |
|------------------------|----------------------------|-----------------------------------|-----------------------------------|
| **惰性删除**           | 访问键时                   | 无额外开销，避免性能抖动          | 冷数据可能长期占用内存            |
| **定期删除**           | 每隔一定时间随机抽样       | 主动清理，减少内存浪费            | 无法保证所有过期键被及时删除      |
| **内存淘汰策略**       | 内存不足时                 | 确保关键数据保留                  | 可能误删未过期键（依赖策略选择）  |

Redis 的混合删除策略通过**惰性删除保证低延迟**，**定期删除控制内存增长**，**内存淘汰策略应对极端情况**，共同实现了高效、可靠的过期键管理。开发者应根据业务场景调整参数（如 `hz`、淘汰策略），并监控 `expired_keys` 指标，确保系统稳定运行。
