# 如何设计一个点赞系统？

**难度**：中等

**创建时间**：2025-10-06 15:44:41

## 答案
设计一个点赞系统需要考虑**功能需求**、**技术架构**、**数据一致性**、**性能优化**和**扩展性**。以下是分步骤的详细设计方案，涵盖从简单到高并发的实现思路。

---

## **一、需求分析**
### **1. 核心功能**
- **用户点赞/取消点赞**：支持用户对内容（如文章、评论、视频）进行点赞或取消操作。
- **实时计数更新**：点赞后立即更新内容的点赞总数，并反馈给用户。
- **防重复点赞**：同一用户对同一内容只能点赞一次，取消后可再次点赞。
- **数据持久化**：点赞记录需保存到数据库，避免系统重启后数据丢失。

### **2. 扩展需求**
- **点赞排行榜**：按点赞数排序热门内容。
- **用户点赞历史**：记录用户点赞过的内容，支持查询。
- **通知机制**：点赞后触发通知（如消息推送、邮件）。
- **防刷机制**：限制同一用户/IP的点赞频率，防止恶意刷赞。

---

## **二、技术架构设计**
### **1. 基础架构**
#### **方案1：单体应用（适合低并发）**
- **前端**：Web/App通过API调用后端服务。
- **后端**：单一服务处理点赞请求，直接操作数据库。
- **数据库**：关系型数据库（如MySQL）存储点赞记录和计数。

#### **方案2：分布式架构（适合高并发）**
- **前端**：同上。
- **API网关**：负载均衡，路由请求到后端服务。
- **微服务**：
  - **点赞服务**：处理点赞逻辑。
  - **计数服务**：维护点赞总数（可用Redis）。
  - **通知服务**：异步发送点赞通知。
- **缓存层**：Redis存储点赞状态和计数，减少数据库压力。
- **消息队列**：RabbitMQ/Kafka异步处理通知和日志。
- **数据库**：MySQL分库分表存储原始数据，ES支持排行榜查询。

---

## **三、数据存储设计**
### **1. 数据库表设计**
#### **方案1：关系型数据库（MySQL）**
```sql
-- 内容表（存储被点赞的对象）
CREATE TABLE content (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    like_count INT DEFAULT 0,
    -- 其他字段...
);

-- 点赞记录表（记录用户点赞行为）
CREATE TABLE like_record (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    content_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY (content_id, user_id), -- 防止重复点赞
    FOREIGN KEY (content_id) REFERENCES content(id)
);
```

#### **方案2：Redis优化**
- **点赞状态**：用Hash存储用户对内容的点赞状态。
  ```redis
  HSET like:status:{content_id} user_id 1  # 1表示已点赞
  ```
- **点赞计数**：用String或HyperLogLog存储总数。
  ```redis
  INCR content:{content_id}:like_count  # 增加计数
  DECR content:{content_id}:like_count  # 减少计数
  ```

---

## **四、核心逻辑实现**
### **1. 点赞流程**
1. **校验权限**：检查用户是否登录，内容是否存在。
2. **防重复点赞**：
   - 查询Redis中`like:status:{content_id}`是否存在该用户的`user_id`。
   - 如果存在，返回“已点赞”；否则继续。
3. **更新计数**：
   - Redis中`INCR content:{content_id}:like_count`。
   - 异步更新MySQL的`like_count`字段（避免直接写库）。
4. **记录点赞**：
   - 将`(content_id, user_id)`插入Redis的Hash和MySQL的`like_record`表。
5. **返回结果**：返回更新后的点赞数。

### **2. 取消点赞流程**
1. **校验权限**：检查用户是否点赞过该内容。
2. **删除状态**：
   - Redis中`HDEL like:status:{content_id} user_id`。
3. **减少计数**：
   - Redis中`DECR content:{content_id}:like_count`。
4. **删除记录**：
   - 从MySQL的`like_record`表中删除对应记录。
5. **返回结果**：返回更新后的点赞数。

---

## **五、性能优化**
### **1. 缓存策略**
- **Redis缓存点赞数**：直接从Redis读取计数，异步同步到MySQL。
- **本地缓存**：服务端用Guava Cache缓存热点内容的点赞数。

### **2. 异步处理**
- **消息队列**：点赞操作写入MQ，由消费者异步更新MySQL和发送通知。
  ```java
  // 伪代码：点赞后发布消息
  rabbitTemplate.convertAndSend("like.exchange", "like.event", likeEvent);
  ```

### **3. 数据库优化**
- **分库分表**：按`content_id`或`user_id`分表，解决单表数据量过大问题。
- **读写分离**：主库写，从库读点赞数。

### **4. 防刷机制**
- **IP限制**：同一IP每分钟最多点赞10次（可用Redis计数）。
  ```redis
  INCR limit:ip:{ip_address}:like  # 计数
  EXPIRE limit:ip:{ip_address}:like 60  # 60秒过期
  ```
- **用户行为分析**：通过规则引擎（如Drools）检测异常点赞模式。

---

## **六、高并发场景解决方案**
### **1. 数据库锁问题**
- **问题**：并发点赞可能导致`like_count`计数错误。
- **解决方案**：
  - **Redis原子操作**：用`INCR`/`DECR`保证计数正确。
  - **乐观锁**：MySQL中更新时加版本号。
    ```sql
    UPDATE content SET like_count = like_count + 1, version = version + 1 
    WHERE id = {content_id} AND version = {old_version};
    ```

### **2. 缓存穿透/雪崩**
- **缓存穿透**：恶意请求不存在的`content_id`，导致频繁查库。
  - **解决方案**：缓存空值或用布隆过滤器过滤无效请求。
- **缓存雪崩**：大量缓存同时失效，导致数据库压力激增。
  - **解决方案**：设置随机过期时间，或加互斥锁。

### **3. 分布式锁**
- **场景**：多个服务实例同时处理点赞请求。
- **解决方案**：用Redis的`SETNX`实现分布式锁。
  ```redis
  SET lock:like:{content_id} "1" EX 10 NX  # 10秒过期
  ```

---

## **七、扩展功能实现**
### **1. 点赞排行榜**
- **方案1**：Redis的`ZSET`（有序集合）实时维护热门内容。
  ```redis
  ZADD hot_content 1000 content_1  # 1000为点赞数
  ZREVRANGE hot_content 0 9  # 获取前10名
  ```
- **方案2**：ES聚合查询，按`like_count`排序。

### **2. 用户点赞历史**
- **方案1**：MySQL查询`like_record`表，按时间倒序。
- **方案2**：Redis的`ZSET`存储用户点赞历史，按时间排序。
  ```redis
  ZADD user:{user_id}:likes {timestamp} content_id
  ZREVRANGE user:{user_id}:likes 0 9  # 获取最近10条
  ```

---

## **八、代码示例（简化版）**
### **1. 后端API（Spring Boot）**
```java
@RestController
@RequestMapping("/api/like")
public class LikeController {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @PostMapping("/{contentId}")
    public ResponseEntity<?> like(@PathVariable Long contentId, @RequestParam Long userId) {
        // 1. 检查是否已点赞
        Boolean hasLiked = redisTemplate.opsForHash().hasKey("like:status:" + contentId, userId.toString());
        if (Boolean.TRUE.equals(hasLiked)) {
            return ResponseEntity.badRequest().body("已点赞");
        }

        // 2. 更新Redis计数和状态
        redisTemplate.opsForValue().increment("content:" + contentId + ":like_count");
        redisTemplate.opsForHash().put("like:status:" + contentId, userId.toString(), "1");

        // 3. 异步更新MySQL（伪代码）
        asyncService.updateLikeCount(contentId);
        asyncService.recordLike(contentId, userId);

        // 4. 返回结果
        Long count = Long.parseLong(redisTemplate.opsForValue().get("content:" + contentId + ":like_count"));
        return ResponseEntity.ok(Map.of("count", count));
    }
}
```

### **2. 前端交互（Vue.js）**
```javascript
async function like(contentId) {
    const userId = getUserId(); // 从本地存储获取用户ID
    const response = await fetch(`/api/like/${contentId}?userId=${userId}`, { method: 'POST' });
    const data = await response.json();
    updateLikeButton(data.count); // 更新UI
}
```

---

## **九、总结**
| **优化点**               | **方案**                                                                 |
|--------------------------|--------------------------------------------------------------------------|
| **低并发**               | 单体应用 + MySQL                                                         |
| **高并发**               | 分布式服务 + Redis缓存 + 消息队列                                        |
| **数据一致性**           | Redis原子操作 + 异步同步MySQL                                            |
| **防刷**                 | IP/用户限流 + 分布式锁                                                   |
| **扩展功能**             | Redis ZSET排行榜 + ES聚合查询                                           |

根据实际业务场景选择合适的方案：  
- **初创项目**：直接用MySQL + 简单缓存。  
- **中大型项目**：采用Redis + 微服务 + 异步处理，确保高可用和可扩展性。
