# 如何设计一个秒杀功能？

**难度**：困难

**创建时间**：2025-10-06 15:42:55

## 答案
设计一个高并发的秒杀系统需要综合考虑性能、一致性和防刷机制。以下是分步骤的详细设计方案，涵盖技术选型、核心模块和优化策略：

---

### **一、核心设计目标**
1. **高并发支持**：应对每秒数万级请求
2. **超卖防护**：确保库存准确，避免负数
3. **防刷机制**：阻止机器人和恶意请求
4. **系统稳定性**：避免雪崩效应
5. **用户体验**：快速反馈结果，减少等待

---

### **二、系统架构分层**
```
客户端 → 负载均衡 → 秒杀网关 → 缓存层 → 队列服务 → 业务服务 → 数据库
```

#### 1. 前端优化
- **静态资源CDN**：将静态页面（HTML/CSS/JS）部署到CDN
- **按钮灰化**：提交后立即禁用按钮，防止重复提交
- **倒计时同步**：通过WebSocket实时同步服务器时间
- **验证码机制**：
  - 滑动拼图验证
  - 短信验证码（高价值商品）
  - 行为指纹（鼠标轨迹分析）

#### 2. 网关层（API Gateway）
- **限流策略**：
  - 令牌桶算法（如Guava RateLimiter）
  - 分布式限流（Redis + Lua脚本）
  ```lua
  -- Redis限流脚本示例
  local key = KEYS[1]
  local limit = tonumber(ARGV[1])
  local current = tonumber(redis.call("GET", key) or "0")
  if current + 1 > limit then
      return 0
  else
      redis.call("INCR", key)
      if tonumber(ARGV[2]) > 0 then
          redis.call("EXPIRE", key, ARGV[2])
      end
      return 1
  end
  ```
- **IP黑名单**：自动封禁异常IP（如每秒100+请求）
- **请求参数校验**：提前过滤非法请求（如负数价格）

#### 3. 缓存层（Redis集群）
- **库存预热**：
  ```bash
  # 初始化库存（活动开始前5分钟）
  SET seckill:stock:1001 1000  # 商品ID:1001，库存1000
  ```
- **原子减库存**：
  ```lua
  -- Redis Lua脚本保证原子性
  local stockKey = KEYS[1]
  local userKey = KEYS[2]
  local userId = ARGV[1]
  
  -- 检查用户是否已购买
  if redis.call("SISMEMBER", userKey, userId) == 1 then
      return 0  -- 已购买
  end
  
  -- 减库存
  local stock = tonumber(redis.call("GET", stockKey) or "0")
  if stock <= 0 then
      return 0  -- 库存不足
  end
  
  redis.call("DECR", stockKey)
  redis.call("SADD", userKey, userId)
  return 1
  ```
- **分布式锁**（可选）：
  ```java
  // Redisson分布式锁示例
  RLock lock = redisson.getLock("seckill_lock_1001");
  try {
      lock.lock(10, TimeUnit.SECONDS);
      // 执行库存操作
  } finally {
      lock.unlock();
  }
  ```

#### 4. 消息队列（RabbitMQ/Kafka）
- **异步削峰**：
  ```java
  // 伪代码：将秒杀请求放入队列
  channel.basicPublish("seckill_exchange", "seckill.order",
      MessageProperties.PERSISTENT_TEXT_PLAIN,
      orderJson.getBytes());
  ```
- **消费者组**：
  - 多个消费者实例并行处理
  - 设置预取数（prefetch count）控制并发量

#### 5. 业务服务层
- **预减库存**：
  ```sql
  -- 数据库层面预留库存（非实时）
  UPDATE seckill_goods 
  SET stock = stock - 1 
  WHERE goods_id = 1001 AND stock > 0;
  ```
- **异步下单**：
  ```java
  @Transactional
  public void createOrder(SeckillOrder order) {
      // 1. 创建订单记录
      orderDao.insert(order);
      
      // 2. 扣减实际库存（最终一致性）
      goodsDao.reduceStock(order.getGoodsId());
      
      // 3. 发送支付通知
      paymentService.notify(order.getOrderId());
  }
  ```
- **幂等性处理**：
  - 订单号生成：`雪花算法(Snowflake)` + 用户ID
  - 数据库唯一约束：
    ```sql
    ALTER TABLE seckill_orders ADD UNIQUE KEY (user_id, goods_id);
    ```

#### 6. 数据库层
- **分库分表**：
  - 按商品ID分库（如10个库）
  - 使用ShardingSphere或MyCat
- **读写分离**：
  - 主库写，从库读
- **索引优化**：
  ```sql
  -- 订单表索引
  CREATE INDEX idx_user_goods ON seckill_orders(user_id, goods_id);
  ```

---

### **三、关键优化点**
#### 1. 库存控制三板斧
| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **缓存预减** | 性能最高 | 可能超卖 | 允许少量超卖的场景 |
| **数据库乐观锁** | 绝对准确 | 并发高时性能差 | 强一致性要求的场景 |
| **队列串行化** | 平衡性能与一致性 | 实现复杂 | 中等并发场景 |

#### 2. 防超卖组合方案
```java
// 伪代码：三层防护
public boolean seckill(Long userId, Long goodsId) {
    // 1. 缓存层校验
    if (!redis.decrStock(goodsId)) {
        return false;
    }
    
    // 2. 消息队列异步处理
    try {
        mq.send(new SeckillMessage(userId, goodsId));
    } catch (Exception e) {
        // 回滚缓存库存
        redis.incrStock(goodsId);
        return false;
    }
    
    return true;
}
```

#### 3. 降级方案
- **服务降级**：
  - 当QPS > 10万时，自动关闭非核心功能（如商品详情页）
- **熔断机制**：
  ```java
  // Hystrix熔断示例
  @HystrixCommand(fallbackMethod = "seckillFallback")
  public boolean seckill(Long userId, Long goodsId) {
      // 正常逻辑
  }
  
  public boolean seckillFallback(Long userId, Long goodsId) {
      return false; // 返回"系统繁忙"
  }
  ```

---

### **四、监控与告警**
1. **实时指标**：
   - 请求QPS（Prometheus + Grafana）
   - 库存变化率（Redis监控）
   - 订单创建延迟（ELK日志分析）
2. **异常告警**：
   - 库存突降（超过阈值50%）
   - 500错误率 > 1%
   - 队列积压 > 1000条

---

### **五、完整流程示例**
1. 用户点击秒杀按钮 → 触发前端验证
2. 请求到达网关 → 通过IP限流和验证码校验
3. 查询Redis库存 → 库存不足直接返回失败
4. 执行Lua脚本原子减库存 → 成功则返回排队中
5. 请求进入RabbitMQ → 消费者异步处理
6. 创建数据库订单 → 记录唯一索引防止重复
7. 返回最终结果 → 通过WebSocket推送通知

---

### **六、压测数据参考**
| 优化措施 | 吞吐量提升 | 响应时间降低 |
|----------|------------|--------------|
| 缓存预减 | 300%       | 80%          |
| 消息队列 | 500%       | 90%          |
| 分库分表 | 200%       | 50%          |
| 静态化   | 150%       | 70%          |

---

### **七、避坑指南**
1. **不要直接操作数据库**：单库单表在1000+ QPS时会崩溃
2. **避免同步调用**：如秒杀后同步查询物流信息
3. **慎用分布式锁**：Redis锁在集群模式下可能有bug
4. **防止缓存穿透**：对不存在的商品ID返回空值缓存
5. **监控内存使用**：Redis集群内存不足会导致OOM

通过这种分层设计，系统可以轻松支撑每秒数万次的秒杀请求，同时保证数据一致性。实际实施时建议先在小流量活动（如内部测试）验证，再逐步放大流量。
