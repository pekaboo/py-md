# Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？

**难度**：中等

**创建时间**：2025-10-06 15:46:37

## 答案
在 Redis 缓存的使用中，**缓存击穿（Cache Breakdown）**、**缓存穿透（Cache Penetration）** 和 **缓存雪崩（Cache Avalanche）** 是三种常见的性能问题，它们都可能导致数据库压力激增甚至系统崩溃。以下是它们的定义、原因、影响及解决方案的详细说明：

---

### **1. 缓存击穿（Cache Breakdown）**
#### **定义**
当某个**热点 key** 在缓存中过期时，大量并发请求同时访问该 key，导致所有请求直接穿透到数据库，造成数据库瞬间压力过大。

#### **典型场景**
- 某个热门商品（如“iPhone 15”）的库存信息被高频访问。
- 缓存设置了较短的过期时间（如 5 分钟），当缓存刚好过期时，大量请求同时到达。

#### **影响**
- 数据库被突发流量打垮，响应变慢甚至崩溃。
- 用户体验下降，系统可用性降低。

#### **解决方案**
- **互斥锁（Mutex Lock）**：
  - 当缓存未命中时，加锁保证只有一个线程查询数据库，其他线程等待并重试。
  - 示例代码（伪代码）：
    ```python
    def get_data(key):
        data = redis.get(key)
        if not data:
            lock = acquire_lock(key)  # 获取分布式锁
            if lock:
                try:
                    data = redis.get(key)
                    if not data:
                        data = db.query(key)  # 查询数据库
                        redis.set(key, data, ex=3600)  # 写入缓存
                finally:
                    release_lock(lock)  # 释放锁
            else:
                sleep(0.1)  # 等待后重试
                return get_data(key)
        return data
    ```
- **逻辑过期**：
  - 不设置真实的过期时间，而是为缓存数据添加一个“逻辑过期字段”。
  - 后台线程异步更新缓存，避免前台请求阻塞。
- **永不过期**：
  - 对热点 key 不设置过期时间，通过后台任务定期刷新（需权衡数据一致性）。

---

### **2. 缓存穿透（Cache Penetration）**
#### **定义**
当查询一个**不存在的 key** 时，缓存和数据库中均无数据，导致所有请求直接穿透到数据库，形成恶性循环。

#### **典型场景**
- 攻击者故意请求不存在的 ID（如 `GET /data?id=-1`）。
- 业务逻辑错误，生成了大量无效 key（如用户 ID 范围错误）。

#### **影响**
- 数据库被无效请求淹没，浪费资源。
- 可能被利用进行 DDoS 攻击。

#### **解决方案**
- **缓存空值**：
  - 对查询结果为空的 key，也缓存一个空值（如 `NULL`），并设置较短过期时间。
  - 示例：
    ```python
    def get_data(key):
        data = redis.get(key)
        if data is None:
            data = db.query(key)  # 查询数据库
            if data is None:
                redis.setex(key, "NULL", 60)  # 缓存空值1分钟
            else:
                redis.set(key, data, ex=3600)
        return data if data != "NULL" else None
    ```
- **布隆过滤器（Bloom Filter）**：
  - 在缓存前加一层布隆过滤器，快速判断 key 是否存在。
  - 适用于海量数据场景（如黑名单、URL 去重）。
- **接口层校验**：
  - 对参数进行合法性校验（如 ID 必须为正整数），直接拒绝非法请求。

---

### **3. 缓存雪崩（Cache Avalanche）**
#### **定义**
当大量缓存 key 在**同一时间过期**，导致所有请求同时穿透到数据库，引发系统崩溃。

#### **典型场景**
- 缓存设置了相同的过期时间（如统一在凌晨 3 点过期）。
- 缓存服务重启，导致所有缓存失效。

#### **影响**
- 数据库被瞬间高并发请求打垮。
- 系统整体不可用，恢复时间长。

#### **解决方案**
- **分散过期时间**：
  - 为缓存 key 添加随机过期时间（如 `ex=3600 + random(600)`）。
  - 避免大量 key 同时过期。
- **多级缓存**：
  - 使用本地缓存（如 Caffeine） + 分布式缓存（Redis），本地缓存兜底。
- **限流降级**：
  - 对穿透到数据库的请求进行限流（如令牌桶算法）。
  - 返回降级数据（如默认值、错误提示）。
- **预热缓存**：
  - 系统启动时提前加载热点数据到缓存。
  - 适用于可预知的流量高峰（如电商大促）。

---

### **对比总结**
| **问题**       | **原因**                          | **解决方案**                          |
|----------------|-----------------------------------|---------------------------------------|
| **缓存击穿**   | 热点 key 过期，并发请求穿透       | 互斥锁、逻辑过期、永不过期            |
| **缓存穿透**   | 查询不存在的 key，反复穿透数据库  | 缓存空值、布隆过滤器、接口校验        |
| **缓存雪崩**   | 大量 key 同时过期，集体穿透       | 分散过期时间、多级缓存、限流降级      |

---

### **实际案例**
1. **电商秒杀系统**：
   - **问题**：商品库存 key 被高频访问，缓存过期时导致数据库崩溃。
   - **方案**：使用互斥锁 + 逻辑过期，保证只有一个线程更新缓存。

2. **用户信息查询**：
   - **问题**：攻击者请求 `user_id=-1`，导致缓存穿透。
   - **方案**：缓存空值 `{"user_id=-1": "NULL"}`，并设置 10 秒过期。

3. **定时任务缓存**：
   - **问题**：每天 0 点缓存集体过期，引发雪崩。
   - **方案**：为每个 key 的过期时间添加随机偏移（如 `ex=86400 ± 3600`）。

---

### **最佳实践**
- **合理设置过期时间**：避免统一过期，使用随机值。
- **监控与告警**：实时监控缓存命中率、数据库负载。
- **熔断机制**：当数据库 QPS 过高时，直接返回缓存或默认值。
- **分布式锁选型**：使用 Redisson 或 Redis 的 `SETNX` 实现锁。

理解这三种问题及其解决方案，能帮助开发者设计更健壮的缓存系统，避免因缓存问题导致的系统故障。
