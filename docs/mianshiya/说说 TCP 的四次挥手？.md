# 说说 TCP 的四次挥手？

**难度**：简单

**创建时间**：2025-10-06 05:59:51

## 答案
TCP 的四次挥手（Four-Way Handshake）是 TCP 协议中用于**安全终止连接**的机制，确保双方数据传输完成且资源正确释放。与三次握手建立连接不同，四次挥手需要更复杂的交互，因为 TCP 是全双工通信，双方需独立关闭各自的发送通道。以下是详细解析：

---

### **1. 四次挥手的核心目的**
- **终止双向连接**：TCP 连接是双向的（A→B 和 B→A），四次挥手需分别关闭两个方向的通信。
- **防止数据丢失**：确保所有已发送但未确认的数据被完整接收。
- **同步状态**：协调双方从 `ESTABLISHED` 状态转移到 `CLOSED` 状态。

---

### **2. 四次挥手的过程**
假设客户端（Client）主动发起关闭，服务端（Server）响应，过程如下：

#### **(1) 第一次挥手：Client → Server（FIN）**
- **Client 发送 FIN 包**：  
  Client 完成数据发送后，发送一个 `FIN=1` 的 TCP 段（序列号 `seq=u`），表示**不再发送数据**，但可以接收数据。
- **状态变化**：  
  Client 进入 `FIN_WAIT_1` 状态，等待 Server 确认。

#### **(2) 第二次挥手：Server → Client（ACK）**
- **Server 发送 ACK 包**：  
  Server 收到 FIN 后，发送一个 `ACK=1` 的确认包（确认号 `ack=u+1`，序列号 `seq=v`），表示已收到 Client 的关闭请求。
- **状态变化**：  
  Server 进入 `CLOSE_WAIT` 状态，继续接收 Client 的数据（如果有）；  
  Client 收到 ACK 后，进入 `FIN_WAIT_2` 状态，等待 Server 关闭其发送通道。

#### **(3) 第三次挥手：Server → Client（FIN）**
- **Server 发送 FIN 包**：  
  Server 完成数据发送后，发送一个 `FIN=1` 的 TCP 段（序列号 `seq=w`，确认号仍为 `ack=u+1`），表示**不再发送数据**。
- **状态变化**：  
  Server 进入 `LAST_ACK` 状态，等待 Client 的最终确认；  
  Client 收到 Server 的 FIN 后，进入 `TIME_WAIT` 状态。

#### **(4) 第四次挥手：Client → Server（ACK）**
- **Client 发送 ACK 包**：  
  Client 发送一个 `ACK=1` 的确认包（确认号 `ack=w+1`，序列号 `seq=u+1`），表示已收到 Server 的关闭请求。
- **状态变化**：  
  Client 进入 `TIME_WAIT` 状态，等待 2MSL（Maximum Segment Lifetime，通常 2 分钟）后彻底关闭；  
  Server 收到 ACK 后，立即进入 `CLOSED` 状态，释放资源。

---

### **3. 状态转换图**
```
Client                                     Server
ESTABLISHED
  | FIN (seq=u)                          →
  |---------------------------------------->
  |                                       |
FIN_WAIT_1   <---------------------------| CLOSE_WAIT
  | ACK (ack=u+1)                        |
  |<---------------------------------------
  |                                       |
FIN_WAIT_2   <---------------------------| LAST_ACK
  |                                       | FIN (seq=w)
  | ACK (ack=w+1)                        |
  |---------------------------------------->
TIME_WAIT    (等待 2MSL)                  | CLOSED
  |                                       |
  |---------------------------------------> (释放资源)
CLOSED
```

---

### **4. 关键问题解析**
#### **(1) 为什么需要四次挥手？**
- **双向独立关闭**：TCP 是全双工的，一方关闭发送通道（FIN）不影响另一方继续发送数据。因此需要两次独立的 FIN-ACK 交互。
- **数据完整性**：确保双方所有已发送数据被确认接收。例如，Server 可能在收到 Client 的 FIN 后仍有数据要发送。

#### **(2) 为什么 Client 进入 TIME_WAIT 状态？**
- **防止旧连接干扰**：确保最后一个 ACK 到达 Server。如果 ACK 丢失，Server 会重传 FIN，Client 需重新发送 ACK。
- **网络延迟处理**：等待 2MSL 时间，确保所有滞留在网络中的报文段过期，避免与新连接冲突。

#### **(3) 能否合并 ACK 和 FIN？**
- **理论可行，但实际不推荐**：  
  如果 Server 在收到 Client 的 FIN 后立即发送 FIN（合并 ACK 和 FIN），可能因数据未处理完导致数据丢失。四次挥手的设计更可靠。

#### **(4) 主动关闭方 vs 被动关闭方**
- **主动关闭方（Client）**：发起 FIN 的一方，最终进入 TIME_WAIT。
- **被动关闭方（Server）**：响应 FIN 的一方，收到最后一个 ACK 后立即关闭。

---

### **5. 实际场景示例**
- **HTTP 请求终止**：浏览器完成页面加载后，发送 FIN 关闭连接；服务器确认后，可能继续发送日志或统计数据，再发送自己的 FIN。
- **数据库连接关闭**：客户端发送 FIN 表示不再查询，服务器处理完最后一条 SQL 后发送 FIN。

---

### **6. 异常情况处理**
- **FIN 丢失**：主动方重传 FIN（超时重传机制）。
- **ACK 丢失**：被动方重传 FIN（进入 LAST_ACK 后启动重传计时器）。
- **半关闭状态**：一方调用 `shutdown()` 仅关闭发送通道，仍可接收数据（需应用层显式控制）。

---

### **总结**
TCP 的四次挥手通过**分步关闭双向通道**，确保了连接的可靠终止。其核心在于：
1. **独立关闭**：全双工通信需要两次独立的 FIN-ACK 交互。
2. **状态同步**：通过状态机（如 FIN_WAIT、CLOSE_WAIT）管理关闭过程。
3. **容错设计**：TIME_WAIT 状态和重传机制处理网络异常。

理解四次挥手有助于调试网络问题（如连接卡在 CLOSE_WAIT）、优化服务器性能（如调整 TIME_WAIT 参数），以及设计高可靠的分布式系统。
