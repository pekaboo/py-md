# MySQL 中有哪些锁类型？

**难度**：中等

**创建时间**：2025-10-05 12:11:48

## 答案
MySQL 中的锁机制是保证数据一致性和并发控制的核心，不同类型的锁适用于不同的场景。MySQL 的锁主要分为 **按粒度划分** 和 **按行为划分** 两大类，以下是详细分类和说明：

---

## **一、按锁的粒度划分**
锁的粒度决定了锁定的数据范围，粒度越细，并发性越高，但管理成本也越高。

### **1. 全局锁（Global Lock）**
- **作用范围**：整个 MySQL 实例。
- **命令**：`FLUSH TABLES WITH READ LOCK`（FTWRL）。
- **特点**：
  - 锁定后，所有表处于只读状态，禁止写操作（DDL 和 DML）。
  - 通常用于全库备份（如 `mysqldump`），确保备份期间数据一致。
- **缺点**：
  - 阻塞所有写操作，影响高并发应用。
  - 仅建议短时间使用（如备份期间）。

### **2. 表级锁（Table-Level Lock）**
锁定整张表，粒度粗但开销小，适用于低并发或表数据量小的场景。

#### **(1) 表锁（Table Lock）**
- **命令**：
  - 显式加锁：`LOCK TABLES tbl_name READ/WRITE`，`UNLOCK TABLES`。
  - 隐式加锁：MySQL 自动管理（如 DDL 操作会隐式加表锁）。
- **类型**：
  - **读锁（共享锁 S）**：多个事务可同时持有，但阻塞写锁。
  - **写锁（排他锁 X）**：独占锁，阻塞其他读锁和写锁。
- **适用场景**：
  - 表数据量小或并发低。
  - 需要显式控制表访问的场景（如维护时锁定表）。

#### **(2) 元数据锁（MDL, MetaData Lock）**
- **作用**：保护表结构（元数据）不被并发修改。
- **触发时机**：
  - 执行 DML（如 `SELECT`）时自动加 **MDL 读锁**。
  - 执行 DDL（如 `ALTER TABLE`）时自动加 **MDL 写锁**。
- **特点**：
  - 读锁与读锁不冲突，但写锁会阻塞所有读锁和写锁。
  - 长事务可能导致 DDL 阻塞（如事务未提交时无法修改表结构）。
- **案例**：
  ```sql
  -- 事务1（长事务未提交）
  BEGIN;
  SELECT * FROM users; -- 持有 MDL 读锁

  -- 事务2（阻塞）
  ALTER TABLE users ADD COLUMN age INT; -- 等待 MDL 写锁
  ```

#### **(3) 意向锁（Intention Lock）**
- **作用**：表级锁与行级锁共存时的协调机制，避免检查每行锁状态。
- **类型**：
  - **意向共享锁（IS）**：事务打算在表中的某些行加共享锁。
  - **意向排他锁（IX）**：事务打算在表中的某些行加排他锁。
- **规则**：
  - 加行锁前必须先加意向锁（如加 `S` 锁前加 `IS`，加 `X` 锁前加 `IX`）。
  - 表级意向锁与行级锁不冲突，但表级写锁会阻塞所有行锁。

### **3. 行级锁（Row-Level Lock）**
锁定表中的单行或多行，粒度细，并发性高，但开销大。**仅 InnoDB 支持**。

#### **(1) 记录锁（Record Lock）**
- **作用**：锁定索引记录（即使表无索引，也会隐式创建聚簇索引锁）。
- **类型**：
  - **共享锁（S）**：`SELECT ... LOCK IN SHARE MODE`（MySQL 8.0+ 推荐用 `SELECT ... FOR SHARE`）。
  - **排他锁（X）**：`SELECT ... FOR UPDATE` 或 `UPDATE/DELETE` 默认加排他锁。
- **案例**：
  ```sql
  -- 事务1
  BEGIN;
  SELECT * FROM users WHERE id=1 FOR UPDATE; -- 对id=1的行加X锁

  -- 事务2（阻塞）
  UPDATE users SET name='Bob' WHERE id=1; -- 等待X锁释放
  ```

#### **(2) 间隙锁（Gap Lock）**
- **作用**：锁定索引记录之间的间隙（防止其他事务插入数据），解决幻读问题。
- **触发条件**：
  - 隔离级别为 `REPEATABLE READ`（默认）。
  - 查询条件使用索引且非唯一索引（唯一索引的等值查询不加间隙锁）。
- **案例**：
  ```sql
  -- 事务1
  BEGIN;
  SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE; -- 锁定id=10~20的间隙

  -- 事务2（阻塞）
  INSERT INTO users VALUES(15, 'Alice'); -- 等待间隙锁释放
  ```

#### **(3) 临键锁（Next-Key Lock）**
- **作用**：记录锁 + 间隙锁的组合，锁定索引记录及其前一个间隙。
- **触发条件**：
  - 隔离级别为 `REPEATABLE READ`。
  - 查询条件使用非唯一索引。
- **案例**：
  ```sql
  -- 假设users表的age列有索引(非唯一)
  -- 事务1
  BEGIN;
  SELECT * FROM users WHERE age=30 FOR UPDATE; -- 锁定age=30的记录及相邻间隙

  -- 事务2（阻塞）
  INSERT INTO users VALUES(2, 30); -- 等待临键锁释放
  ```

#### **(4) 插入意向锁（Insert Intention Lock）**
- **作用**：事务在插入行前设置的间隙锁，表示有意图插入数据。
- **特点**：
  - 与间隙锁兼容（多个事务可在同一间隙加插入意向锁，但不冲突）。
  - 若间隙已被其他事务的间隙锁锁定，则插入意向锁会阻塞。

---

## **二、按锁的行为划分**
### **1. 共享锁（S, Shared Lock）**
- **别名**：读锁。
- **特点**：
  - 多个事务可同时持有。
  - 阻塞排他锁（X）。
- **命令**：
  ```sql
  SELECT ... LOCK IN SHARE MODE; -- MySQL 8.0+ 推荐用 FOR SHARE
  ```

### **2. 排他锁（X, Exclusive Lock）**
- **别名**：写锁。
- **特点**：
  - 独占锁，阻塞其他所有锁（S 和 X）。
  - 默认由 `UPDATE/DELETE/SELECT ... FOR UPDATE` 加锁。
- **命令**：
  ```sql
  SELECT ... FOR UPDATE;
  ```

### **3. 悲观锁（Pessimistic Lock）**
- **定义**：假设并发冲突会发生，操作前先加锁。
- **实现**：通过 `SELECT ... FOR UPDATE/SHARE` 显式加锁。
- **适用场景**：高冲突环境（如金融交易）。

### **4. 乐观锁（Optimistic Lock）**
- **定义**：假设并发冲突很少，通过版本号或时间戳检测冲突。
- **实现**：
  - 添加版本字段（如 `version INT`），更新时检查版本：
    ```sql
    UPDATE table SET value=new_value, version=version+1 
    WHERE id=1 AND version=old_version;
    ```
  - 若影响行数为 0，说明版本已变更，需重试。
- **适用场景**：读多写少，冲突概率低（如内容管理系统）。

---

## **三、锁的兼容性与阻塞关系**
| **锁类型**       | **当前锁** \ **请求锁** | **S** | **X** | **IS** | **IX** |
|------------------|------------------------|-------|-------|--------|--------|
| **S（共享锁）**   |                        | 兼容  | 阻塞  | 兼容   | 兼容   |
| **X（排他锁）**   |                        | 阻塞  | 阻塞  | 阻塞   | 阻塞   |
| **IS（意向S）**   |                        | 兼容  | 阻塞  | 兼容   | 兼容   |
| **IX（意向X）**   |                        | 兼容  | 阻塞  | 兼容   | 兼容   |

- **规则**：
  - 表级意向锁与行级锁不直接冲突（如表级 IX 与行级 S 兼容）。
  - 行级 S 和 X 锁遵循共享/排他规则。

---

## **四、死锁检测与处理**
### **1. 死锁产生条件**
- 两个或多个事务互相持有对方需要的锁，形成循环等待。
- **案例**：
  ```sql
  -- 事务1
  BEGIN;
  UPDATE users SET name='A' WHERE id=1; -- 加X锁(id=1)
  UPDATE users SET name='B' WHERE id=2; -- 等待X锁(id=2)

  -- 事务2
  BEGIN;
  UPDATE users SET name='C' WHERE id=2; -- 加X锁(id=2)
  UPDATE users SET name='D' WHERE id=1; -- 等待X锁(id=1)
  ```

### **2. MySQL 的死锁处理**
- **自动检测**：InnoDB 会检测死锁并回滚其中一个事务（通常回滚代价较小的事务）。
- **查看死锁日志**：
  ```sql
  SHOW ENGINE INNODB STATUS; -- 在Last detected deadlock部分查看详情
  ```
- **避免策略**：
  - 按固定顺序访问表和行。
  - 减少事务持有锁的时间。
  - 设置合理的锁等待超时（`innodb_lock_wait_timeout`，默认50秒）。

---

## **五、总结与选型建议**
| **锁类型**       | **粒度**   | **并发性** | **适用场景**                     |
|------------------|------------|------------|----------------------------------|
| **全局锁**       | 实例级     | 低         | 全库备份                         |
| **表锁**         | 表级       | 中         | 低并发、表数据量小               |
| **MDL 锁**       | 表级       | 中         | 保护表结构修改                   |
| **意向锁**       | 表级       | 高         | 协调表锁与行锁                   |
| **行锁**         | 行级       | 高         | 高并发、数据量大的场景           |
| **间隙锁/临键锁**| 间隙级     | 中         | 防止幻读（REPEATABLE READ）      |
| **乐观锁**       | 无锁       | 最高       | 读多写少、冲突概率低的场景       |

- **高并发写场景**：优先使用行级锁（如 `SELECT ... FOR UPDATE`）。
- **读多写少场景**：考虑乐观锁或 MVCC（默认隔离级别下 InnoDB 已支持）。
- **避免死锁**：控制事务大小，按固定顺序访问资源。

理解 MySQL 的锁机制能帮助开发者优化事务设计、选择合适的隔离级别，并高效排查锁冲突问题（如死锁、长时间阻塞）。
