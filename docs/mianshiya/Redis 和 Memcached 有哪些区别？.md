# Redis 和 Memcached 有哪些区别？

**难度**：中等

**创建时间**：2025-10-06 15:37:20

## 答案
Redis 和 Memcached 都是高性能的内存键值存储系统，但它们在设计目标、功能特性和应用场景上有显著差异。以下是两者的详细对比：

---

### **一、核心设计差异**
| **维度**       | **Redis**                          | **Memcached**                     |
|----------------|-----------------------------------|-----------------------------------|
| **数据结构**   | 支持多种数据结构（String、Hash、List、Set、Sorted Set、Bitmaps、HyperLogLog、GEO、Stream） | 仅支持简单的键值对（String类型） |
| **持久化**     | 支持RDB快照和AOF日志持久化        | 无持久化，数据仅存在于内存中      |
| **多线程**     | 单线程模型（6.0+支持I/O多线程）   | 多线程模型（工作线程处理请求）    |
| **集群模式**   | 支持原生集群（Redis Cluster）     | 无原生集群，需通过客户端分片或代理（如Twemproxy）实现 |

---

### **二、功能特性对比**
#### **1. 数据结构与操作**
- **Redis**：
  - **丰富数据类型**：  
    - **String**：支持整数/浮点数增减（`INCR`/`HINCRBY`）、过期时间（`EXPIRE`）。  
    - **Hash**：存储对象属性（如用户信息），支持字段级操作。  
    - **List**：双向链表，支持阻塞队列（`BLPOP`/`BRPOP`）。  
    - **Set/Sorted Set**：无序集合/有序集合，支持排名查询（如排行榜）。  
    - **Bitmaps/HyperLogLog**：高效统计位操作/基数估算。  
    - **GEO**：地理位置存储与计算。  
    - **Stream**：消息队列，支持消费者组。  
  - **原子操作**：跨数据结构的原子性（如`MULTI/EXEC`事务）。

- **Memcached**：
  - **仅支持String**：值最大1MB（默认），需手动序列化复杂对象。  
  - **简单操作**：`GET`/`SET`/`DELETE`/`INCR`/`DECR`，无嵌套结构支持。

#### **2. 内存管理**
- **Redis**：
  - **动态内存分配**：使用jemalloc或glibc分配内存，支持碎片整理（`MEMORY PURGE`）。  
  - **对象复用**：共享部分字符串对象（如整数0-10000）。  
  - **过期策略**：主动淘汰（定期删除+惰性删除）+ 内存不足时LRU/LFU/随机淘汰。

- **Memcached**：
  - **Slab分配器**：预分配固定大小的内存块（Slab Class），减少碎片但可能浪费内存。  
  - **LRU淘汰**：基于项的访问时间（无LFU），内存不足时直接淘汰最久未使用数据。

#### **3. 持久化与复制**
- **Redis**：
  - **RDB持久化**：定时生成数据快照（可配置保存点）。  
  - **AOF持久化**：记录所有写操作日志（支持`everysec`/`always`/`no`刷盘策略）。  
  - **主从复制**：支持全量同步+增量同步（PSYNC2），从库可读不可写。

- **Memcached**：
  - **无持久化**：重启后数据丢失，适合缓存场景。  
  - **无复制**：需通过客户端分片或代理实现高可用。

#### **4. 集群与高可用**
- **Redis**：
  - **Redis Cluster**：分片+主从复制，支持自动故障转移（需多数节点同意）。  
  - **哨兵模式（Sentinel）**：监控主从状态，自动提升从库为主库。

- **Memcached**：
  - **客户端分片**：如Ketama一致性哈希，手动管理节点。  
  - **代理方案**：如Twemproxy或McRouter，简化分片逻辑但增加延迟。

---

### **三、性能对比**
| **指标**       | **Redis**                          | **Memcached**                     |
|----------------|-----------------------------------|-----------------------------------|
| **吞吐量**     | 单线程模型下约10万QPS（简单操作） | 多线程模型下更高（依赖CPU核心数） |
| **延迟**       | ~1ms（单线程，无竞争时更低）     | ~0.5ms（多线程，短路径优化）     |
| **大键处理**   | 支持分片（如Hash的`HSCAN`）      | 大键可能导致性能下降（Slab限制） |
| **多键操作**   | 支持（如`MGET`/`MSET`）          | 仅支持单键操作                   |

---

### **四、适用场景**
#### **1. Redis 适用场景**
- **缓存+持久化需求**：如会话缓存、热点数据持久化。  
- **复杂数据结构**：如排行榜（Sorted Set）、消息队列（Stream）、位图统计。  
- **高可用与扩展性**：需要自动故障转移的分布式场景。  
- **原子操作与事务**：如库存扣减、计数器同步。

#### **2. Memcached 适用场景**
- **纯缓存场景**：无需持久化，如HTML片段、API响应缓存。  
- **简单键值存储**：数据格式单一，无需复杂操作。  
- **极高吞吐需求**：多线程架构适合读多写少的场景。  
- **与数据库解耦**：作为数据库查询的快速缓存层。

---

### **五、选型建议**
| **需求**                     | **推荐选择**       |
|------------------------------|--------------------|
| 需要持久化或数据恢复         | Redis              |
| 使用复杂数据结构（如Hash）   | Redis              |
| 需要集群自动管理             | Redis Cluster      |
| 追求极致简单与高性能         | Memcached         |
| 内存敏感且数据模型固定       | Memcached（Slab优化） |
| 需要消息队列或发布订阅       | Redis（Stream/PubSub） |

---

### **六、典型案例**
1. **Redis 案例**：  
   - 电商平台的商品详情页缓存（Hash存储商品属性，Sorted Set存储销量排名）。  
   - 社交网络的点赞系统（Bitmaps统计用户行为，HyperLogLog去重）。

2. **Memcached 案例**：  
   - 新闻网站的页面片段缓存（简单键值，无持久化需求）。  
   - 大型系统的分布式Session存储（客户端分片管理）。

---

### **总结**
- **Redis** 是功能丰富的内存数据库，适合需要持久化、复杂数据结构和高可用的场景。  
- **Memcached** 是极简的高性能缓存，适合纯内存、简单键值和超高吞吐的场景。  
- **实际选型**需综合考虑数据复杂性、持久化需求、集群规模和运维成本。
