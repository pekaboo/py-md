# JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？

**难度**：中等

**创建时间**：2025-10-02 13:07:38

## 答案
JDK 1.8 对 `HashMap` 进行了多方面的优化，除了引入红黑树外，还包括以下关键改动：

### **1. 初始化方式优化：延迟初始化**
- **JDK 1.7**：在构造函数中直接创建容量为 16 的数组，即使未插入数据也会占用内存。
- **JDK 1.8**：采用“懒加载”策略，数组在第一次插入元素时才初始化，减少内存浪费。

**示例**：
```java
HashMap<String, Integer> map = new HashMap<>(); // 此时数组未创建
map.put("key", 1); // 首次插入时初始化数组
```

### **2. 哈希算法改进：扰动函数优化**
- **JDK 1.7**：哈希计算涉及多次移位和异或，但高位信息利用不足。
- **JDK 1.8**：简化哈希函数，通过 `key.hashCode() ^ (h >>> 16)` 将高位和低位混合，使哈希值分布更均匀，减少冲突。

**哈希函数源码**：
```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

### **3. 扩容机制优化：高效数据迁移**
- **JDK 1.7**：扩容时需重新计算所有元素的哈希值，并逐个迁移到新数组。
- **JDK 1.8**：
  - **扩容条件**：元素数量超过 `容量 * 负载因子（默认 0.75）` 时触发。
  - **高效迁移**：通过 `e.hash & oldCap` 判断元素在新数组中的位置是否变化，避免重复计算哈希值。
  - **链表顺序保留**：扩容时保持链表节点相对顺序，防止迭代顺序变化。

**扩容逻辑示例**：
```java
if ((e.hash & oldCap) == 0) {
    // 元素位置不变
} else {
    // 新位置 = 原位置 + 原数组长度
}
```

### **4. 链表与红黑树的动态转换**
- **树化条件**：链表长度超过 8 **且** 数组长度 ≥ 64 时，链表转为红黑树。
- **解树化条件**：红黑树节点数 ≤ 6 时，退化为链表。
- **目的**：平衡查询性能（O(log n)）与空间开销，避免少量节点时红黑树的额外成本。

**树化逻辑源码**：
```java
if (binCount >= TREEIFY_THRESHOLD) { // 默认阈值 8
    treeifyBin(tab, hash);
}
```

### **5. 插入顺序优化：尾插法替代头插法**
- **JDK 1.7**：链表采用头插法，扩容时可能导致链表逆序，引发多线程死循环。
- **JDK 1.8**：改为尾插法，确保链表顺序稳定，解决并发死循环问题（但 `HashMap` 仍非线程安全）。

### **6. 并发性能改进：细粒度锁与 CAS**
- **JDK 1.7**：多线程下需额外同步机制（如 `Collections.synchronizedMap`）。
- **JDK 1.8**：
  - **节点级锁**：对链表/树节点使用 `synchronized`，减少锁竞争。
  - **CAS 操作**：初始化数组和扩容时使用 CAS，提升并发性能。
- **注意**：`HashMap` 仍非线程安全，高并发场景需用 `ConcurrentHashMap`。

### **7. 新增实用方法**
- **`computeIfAbsent`**：简化“存在则获取，不存在则计算并插入”的操作。
  ```java
  map.computeIfAbsent("key", k -> computeValue()); // 替代传统 if-else
  ```
- **`forEach`**：支持高效遍历键值对。
  ```java
  map.forEach((k, v) -> System.out.println(k + ": " + v));
  ```

### **8. 负载因子默认值调整**
- **JDK 1.7**：负载因子默认 0.75，但扩容逻辑较简单。
- **JDK 1.8**：保持 0.75 的默认值，但结合动态树化和扩容优化，进一步平衡性能与空间利用率。

### **总结：JDK 1.8 的优化目标**
| **优化方向**       | **JDK 1.7 问题**                     | **JDK 1.8 解决方案**                     |
|--------------------|--------------------------------------|------------------------------------------|
| **哈希冲突**       | 链表查询 O(n)                        | 红黑树查询 O(log n)                      |
| **扩容效率**       | 需重新计算哈希值                     | 通过位运算快速定位新位置                 |
| **内存占用**       | 初始化即分配数组                     | 延迟初始化减少浪费                       |
| **并发性能**       | 全表锁竞争激烈                       | 节点级锁 + CAS 操作                      |
| **代码简洁性**     | 哈希算法复杂                         | 简化扰动函数，提升可读性                 |

这些改动使 `HashMap` 在 **大数据量、高冲突场景** 下性能更稳定，尤其在单线程或低并发环境中表现优异。但对于高并发场景，仍需使用 `ConcurrentHashMap` 确保线程安全。
