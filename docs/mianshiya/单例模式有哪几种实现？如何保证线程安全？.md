# 单例模式有哪几种实现？如何保证线程安全？

**难度**：中等

**创建时间**：2025-10-06 15:42:42

## 答案
单例模式（Singleton Pattern）确保一个类只有一个实例，并提供全局访问点。其实现方式多样，线程安全是核心问题之一。以下是常见的实现方式及线程安全保证方法：

---

### **一、单例模式的常见实现方式**
#### **1. 饿汉式（Eager Initialization）**
- **特点**：类加载时立即初始化实例（线程安全由 JVM 保证）。
- **优点**：实现简单，无锁，线程安全。
- **缺点**：无法延迟加载，若实例未被使用会造成资源浪费。
```java
public class EagerSingleton {
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    private EagerSingleton() {} // 私有构造函数
    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
}
```

#### **2. 懒汉式（Lazy Initialization）**
- **特点**：延迟初始化实例，首次调用 `getInstance()` 时创建。
- **问题**：非线程安全（多线程下可能创建多个实例）。
```java
public class LazySingleton {
    private static LazySingleton instance;
    private LazySingleton() {}
    public static LazySingleton getInstance() {
        if (instance == null) { // 线程不安全！
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

#### **3. 同步方法（Synchronized Method）**
- **特点**：通过 `synchronized` 关键字保证线程安全。
- **缺点**：每次调用 `getInstance()` 都会同步，性能较差。
```java
public class SynchronizedSingleton {
    private static SynchronizedSingleton instance;
    private SynchronizedSingleton() {}
    public static synchronized SynchronizedSingleton getInstance() {
        if (instance == null) {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }
}
```

#### **4. 双重检查锁定（Double-Checked Locking, DCL）**
- **特点**：减少同步开销，仅在首次初始化时同步。
- **关键点**：使用 `volatile` 防止指令重排序（JDK 5+ 后有效）。
- **优点**：线程安全且高性能。
```java
public class DCLSingleton {
    private static volatile DCLSingleton instance;
    private DCLSingleton() {}
    public static DCLSingleton getInstance() {
        if (instance == null) { // 第一次检查（非同步）
            synchronized (DCLSingleton.class) {
                if (instance == null) { // 第二次检查（同步）
                    instance = new DCLSingleton();
                }
            }
        }
        return instance;
    }
}
```

#### **5. 静态内部类（Holder 模式）**
- **特点**：利用类加载机制保证线程安全，且延迟加载。
- **原理**：静态内部类在首次调用时加载，JVM 保证类加载的线程安全。
- **优点**：无锁，线程安全，代码简洁。
```java
public class HolderSingleton {
    private HolderSingleton() {}
    private static class Holder {
        private static final HolderSingleton INSTANCE = new HolderSingleton();
    }
    public static HolderSingleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

#### **6. 枚举单例（Enum Singleton）**
- **特点**：通过枚举实现单例，天然防止反射攻击和序列化问题。
- **优点**：线程安全，代码最简洁，推荐由《Effective Java》作者 Joshua Bloch 提出。
```java
public enum EnumSingleton {
    INSTANCE;
    public void doSomething() {
        System.out.println("Singleton method");
    }
}
// 调用方式：EnumSingleton.INSTANCE.doSomething();
```

---

### **二、线程安全的保证方法**
#### **1. JVM 层面保证**
- **饿汉式**：类加载时初始化，JVM 保证线程安全。
- **静态内部类**：类加载机制保证线程安全。
- **枚举**：枚举实例的创建由 JVM 控制，线程安全。

#### **2. 同步控制**
- **同步方法**：通过 `synchronized` 关键字阻塞多线程竞争。
- **双重检查锁定**：结合 `volatile` 和同步块，减少同步开销。

#### **3. 避免反射和序列化破坏**
- **反射攻击**：通过 `AccessController.doPrivileged` 禁用反射构造方法（枚举天然免疫）。
- **序列化问题**：实现 `readResolve()` 方法返回唯一实例（枚举无需处理）。
```java
// 防止序列化破坏单例
private Object readResolve() {
    return getInstance();
}
```

---

### **三、不同实现方式的对比**
| **实现方式**       | **线程安全** | **延迟加载** | **性能**       | **复杂度** | **推荐度** |
|--------------------|-------------|-------------|----------------|------------|------------|
| 饿汉式             | 是          | 否          | 高（无锁）     | 低         | ★★★        |
| 同步方法           | 是          | 是          | 低（同步开销） | 低         | ★          |
| 双重检查锁定       | 是          | 是          | 高（仅首次同步）| 中         | ★★★★       |
| 静态内部类         | 是          | 是          | 高（无锁）     | 低         | ★★★★★      |
| 枚举               | 是          | 否（枚举默认初始化） | 最高（无锁） | 最低       | ★★★★★      |

---

### **四、最佳实践建议**
1. **优先使用枚举或静态内部类**：
   - 枚举单例最简洁，且天然防止反射和序列化问题。
   - 静态内部类适合需要延迟加载的场景。
   ```java
   // 推荐方式1：枚举
   public enum Singleton { INSTANCE; }

   // 推荐方式2：静态内部类
   public class Singleton {
       private Singleton() {}
       private static class Holder {
           private static final Singleton INSTANCE = new Singleton();
       }
       public static Singleton getInstance() {
           return Holder.INSTANCE;
       }
   }
   ```

2. **避免懒汉式非同步实现**：多线程环境下会导致实例重复创建。

3. **双重检查锁定需谨慎**：确保使用 `volatile` 变量（JDK 5+）。

4. **考虑单例的生命周期**：若需销毁单例（如资源释放），可提供 `destroy()` 方法并重置实例。

---

### **五、扩展：单例模式的变种**
- **多例模式（Multiton）**：限制类的实例数量（如数据库连接池）。
- **有状态单例**：单例实例包含可变状态（需注意线程安全，如加锁）。
- **依赖注入框架中的单例**：如 Spring 的 `@Bean(scope = "singleton")`。

通过合理选择实现方式，可以兼顾线程安全、性能和代码简洁性。
