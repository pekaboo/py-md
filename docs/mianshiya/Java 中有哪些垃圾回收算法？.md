# Java 中有哪些垃圾回收算法？

**难度**：中等

**创建时间**：2025-10-06 15:46:31

## 答案
在 Java 中，垃圾回收（Garbage Collection, GC）是 JVM 自动管理内存的核心机制，通过回收不再使用的对象来释放内存。Java 的垃圾回收算法主要基于**分代收集理论**（将堆内存分为不同代，针对不同代采用不同策略），以下是常见的垃圾回收算法及其实现：

---

### **一、基础垃圾回收算法**
#### **1. 标记-清除算法（Mark-Sweep）**
- **原理**：  
  1. **标记阶段**：从 GC Roots（如栈帧中的引用、静态变量等）出发，遍历对象图，标记所有存活对象。  
  2. **清除阶段**：回收未被标记的对象（即垃圾对象）占用的内存。  
- **优点**：  
  - 实现简单，不需要移动对象。  
- **缺点**：  
  - 产生内存碎片（分配大对象时可能触发 Full GC）。  
- **应用场景**：  
  - 早期 Java 版本使用，现代 JVM 通常结合其他算法优化。

#### **2. 复制算法（Copying）**
- **原理**：  
  - 将内存分为两块大小相等的区域（From 和 To），每次只使用其中一块。  
  - 存活对象从 From 区复制到 To 区，然后清空 From 区。  
- **优点**：  
  - 无内存碎片，分配效率高（指针碰撞）。  
- **缺点**：  
  - 内存利用率低（仅使用一半内存）。  
  - 复制对象开销大（尤其存活对象多时）。  
- **应用场景**：  
  - Java 新生代（Young Generation）的 **Survivor 区**（Eden + From/To Survivor）。

#### **3. 标记-整理算法（Mark-Compact）**
- **原理**：  
  1. **标记阶段**：同标记-清除算法，标记存活对象。  
  2. **整理阶段**：将所有存活对象向内存一端移动，然后清理边界外的内存。  
- **优点**：  
  - 无内存碎片，适合老年代（对象存活率高）。  
- **缺点**：  
  - 移动对象开销大（STW 时间较长）。  
- **应用场景**：  
  - Java 老年代（Old Generation）的 **Serial Old 和 Parallel Old 收集器**。

---

### **二、分代收集算法（Generational Collection）**
Java 堆内存分为**新生代（Young Generation）**和**老年代（Old Generation）**，不同代采用不同的回收策略：

#### **1. 新生代（Young Generation）**
- **特点**：对象生命周期短，大部分对象很快死亡（“朝生夕死”）。  
- **分区**：  
  - **Eden 区**：新对象分配区域。  
  - **Survivor 区（From/To）**：存放 Minor GC 后存活的对象。  
- **回收算法**：  
  - **Minor GC**：使用 **复制算法**（Eden + From Survivor → To Survivor）。  
  - 对象经过多次 Minor GC 后存活，晋升到老年代。

#### **2. 老年代（Old Generation）**
- **特点**：对象存活率高，内存分配连续。  
- **回收算法**：  
  - **Full GC**：通常使用 **标记-整理算法**（Serial Old/Parallel Old）或 **标记-清除算法**（CMS 的部分阶段）。  
  - 触发条件：老年代空间不足、System.gc() 等。

---

### **三、Java 中的垃圾收集器（GC 实现）**
JVM 提供了多种垃圾收集器，它们基于上述算法并针对不同场景优化：

#### **1. 新生代收集器**
- **Serial GC**  
  - 单线程，使用复制算法。  
  - 适用于客户端模式（Client VM）或小型应用。  
  - 命令行参数：`-XX:+UseSerialGC`。

- **Parallel Scavenge（并行收集器）**  
  - 多线程并行执行 Minor GC，使用复制算法。  
  - 关注吞吐量（高效率），适用于后台计算任务。  
  - 命令行参数：`-XX:+UseParallelGC`（默认 Server VM）。

- **ParNew**  
  - Parallel Scavenge 的多线程版本，专为配合 CMS 设计。  
  - 命令行参数：`-XX:+UseParNewGC`（已废弃，推荐使用 G1）。

#### **2. 老年代收集器**
- **Serial Old GC**  
  - 单线程，使用标记-整理算法。  
  - 适用于客户端模式或与 Parallel Scavenge 配合。  
  - 命令行参数：`-XX:+UseSerialOldGC`。

- **Parallel Old GC**  
  - 多线程并行执行 Full GC，使用标记-整理算法。  
  - 与 Parallel Scavenge 配合，关注吞吐量。  
  - 命令行参数：`-XX:+UseParallelOldGC`。

- **CMS（Concurrent Mark-Sweep）**  
  - **并发标记清除**，减少 STW（Stop-The-World）时间。  
  - 阶段：初始标记 → 并发标记 → 重新标记 → 并发清除。  
  - 缺点：内存碎片、对 CPU 资源敏感。  
  - 命令行参数：`-XX:+UseConcMarkSweepGC`（Java 9+ 已废弃）。

#### **3. 跨代收集器（G1 和 ZGC/Shenandoah）**
- **G1（Garbage-First）**  
  - **面向服务端**，将堆划分为多个大小相等的 Region。  
  - **混合回收**：优先回收价值高的 Region（垃圾多）。  
  - 阶段：初始标记 → 并发标记 → 最终标记 → 筛选回收。  
  - 命令行参数：`-XX:+UseG1GC`（Java 9+ 默认）。  

- **ZGC（Z Garbage Collector）**  
  - **超低延迟**（JDK 11+ 引入），基于染色指针和读屏障实现并发整理。  
  - 适用于大堆（TB 级）和低延迟场景（如金融交易）。  
  - 命令行参数：`-XX:+UseZGC`。  

- **Shenandoah**  
  - OpenJDK 开发的低延迟收集器，与 ZGC 类似但实现不同。  
  - 命令行参数：`-XX:+UseShenandoahGC`。

---

### **四、算法对比与选型建议**
| 算法/收集器       | 适用场景                          | 优点                          | 缺点                          |
|--------------------|-----------------------------------|-------------------------------|-------------------------------|
| **标记-清除**      | 早期 JVM 或简单场景               | 实现简单                      | 内存碎片                      |
| **复制算法**        | 新生代（Minor GC）                | 无碎片，分配快                | 内存利用率低                  |
| **标记-整理**      | 老年代（Full GC）                 | 无碎片                        | 移动对象开销大                |
| **Serial GC**      | 客户端或小型应用                  | 单线程简单，无竞争            | 吞吐量低                      |
| **Parallel GC**   | 计算密集型后台任务                | 高吞吐量                      | STW 时间较长                  |
| **CMS**            | 需要低延迟的交互式应用            | 并发收集，STW 时间短          | 内存碎片，对 CPU 敏感         |
| **G1**             | 服务端通用场景                    | 可预测停顿，混合回收          | 实现复杂                      |
| **ZGC/Shenandoah** | 大堆、超低延迟（如实时系统）      | 亚毫秒级停顿                  | JDK 版本要求高                |

**选型建议**：  
1. **默认选择**：Java 8+ 优先用 `G1`（`-XX:+UseG1GC`），Java 11+ 可尝试 `ZGC`。  
2. **高吞吐量**：用 `Parallel GC`（`-XX:+UseParallelGC`）。  
3. **超低延迟**：用 `ZGC` 或 `Shenandoah`（需 JDK 11+）。  
4. **避免使用**：`CMS`（已废弃）和 `Serial GC`（仅限测试）。

---

### **五、总结**
Java 的垃圾回收算法围绕**分代假设**设计，结合不同场景优化：  
- **新生代**：复制算法（Minor GC）。  
- **老年代**：标记-整理或标记-清除（Full GC）。  
- **现代收集器**：G1、ZGC 等通过并发、分区、压缩等技术平衡吞吐量和延迟。  

理解这些算法和收集器的特性，有助于根据应用需求（如延迟、吞吐量、堆大小）选择合适的 GC 策略。
