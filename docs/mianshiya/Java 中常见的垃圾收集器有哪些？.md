# Java 中常见的垃圾收集器有哪些？

**难度**：中等

**创建时间**：2025-10-06 15:45:29

## 答案
在 Java 中，垃圾收集器（Garbage Collector, GC）是 JVM 内存管理的核心组件，负责自动回收不再使用的对象内存。不同的垃圾收集器在**吞吐量**、**延迟**和**内存占用**上有不同的权衡。以下是 Java 中常见的垃圾收集器及其特点：

---

## **1. 串行收集器（Serial GC）**
### **特点**
- **单线程**：垃圾回收时仅使用一个线程，暂停所有应用线程（Stop-The-World, STW）。
- **简单高效**：适用于单核 CPU 或内存较小的场景（如嵌入式设备）。
- **客户端默认**：Java 8 及之前版本的客户端模式（`-client`）默认使用。

### **适用场景**
- 单核 CPU 环境。
- 对延迟不敏感的小型应用。

### **JVM 参数**
```bash
-XX:+UseSerialGC  # 新生代和老年代均使用串行收集器
```

---

## **2. 并行收集器（Parallel GC / Throughput GC）**
### **特点**
- **多线程并行**：使用多个线程进行垃圾回收，缩短 STW 时间。
- **高吞吐量**：通过最大化 CPU 利用率提升吞吐量（适合后台计算任务）。
- **服务器默认**：Java 8 及之前版本的服务器模式（`-server`）默认使用。

### **细分类型**
- **Parallel Scavenge**（新生代）：基于复制算法，多线程并行回收。
- **Parallel Old**（老年代）：基于标记-整理算法，多线程并行回收。

### **适用场景**
- 多核 CPU 且对吞吐量要求高的场景（如批处理、科学计算）。
- 允许较长的 STW 停顿（通常 100ms~1s）。

### **JVM 参数**
```bash
-XX:+UseParallelGC       # 新生代使用 Parallel Scavenge，老年代使用 Serial Old
-XX:+UseParallelOldGC    # 新生代和老年代均使用并行收集器（推荐）
```

---

## **3. CMS 收集器（Concurrent Mark-Sweep）**
### **特点**
- **并发回收**：大部分回收阶段与应用线程并发执行，减少 STW 停顿。
- **低延迟**：适合对响应时间敏感的应用（如 Web 服务）。
- **标记-清除**：老年代使用标记-清除算法，可能产生内存碎片。
- **已废弃**：Java 9 开始标记为废弃，Java 14 移除。

### **回收阶段**
1. **初始标记**（STW）：标记 GC Roots 直接关联的对象。
2. **并发标记**：与应用线程并发标记存活对象。
3. **重新标记**（STW）：修正并发标记期间的变化。
4. **并发清理**：清除未标记的垃圾对象。

### **缺点**
- 对 CPU 资源敏感（并发阶段占用 CPU）。
- 无法处理浮动垃圾（并发阶段新产生的垃圾）。
- 内存碎片问题需通过 `-XX:+UseCMSCompactAtFullCollection` 定期整理。

### **JVM 参数**
```bash
-XX:+UseConcMarkSweepGC  # 已废弃，不推荐使用
```

---

## **4. G1 收集器（Garbage-First GC）**
### **特点**
- **分区内存**：将堆划分为多个大小相等的 Region（默认约 2048 个），优先回收垃圾最多的 Region。
- **可预测停顿**：通过 `-XX:MaxGCPauseMillis` 设定目标停顿时间（默认 200ms）。
- **并发与并行**：结合并发标记和并行整理，减少 STW 停顿。
- **Java 9+ 默认**：替代 CMS 成为主流低延迟收集器。

### **回收阶段**
1. **年轻代 GC**：回收 Eden 区的对象，存活对象移至 Survivor 或 Old 区。
2. **并发标记周期**：
   - 初始标记（STW）
   - 根区域扫描（与年轻代 GC 并行）
   - 并发标记
   - 最终标记（STW）
   - 清理（统计存活对象，为混合回收做准备）
3. **混合回收**：同时回收年轻代和部分老年代 Region。

### **适用场景**
- 大堆内存（>4GB）且对延迟敏感的应用（如实时系统）。
- 需要可预测停顿时间的场景。

### **JVM 参数**
```bash
-XX:+UseG1GC  # 启用 G1 收集器
-XX:MaxGCPauseMillis=200  # 设置目标最大停顿时间（毫秒）
```

---

## **5. ZGC（Z Garbage Collector）**
### **特点**
- **超低延迟**：目标停顿时间 <10ms，适合大规模数据场景。
- **并发整理**：使用染色指针（Colored Pointers）和读屏障（Load Barrier）实现并发压缩。
- **无分代设计**：统一处理所有年龄的对象（但实际仍隐式分代）。
- **Java 11+ 实验性支持**：Java 15 成为正式功能。

### **适用场景**
- 超低延迟要求的场景（如金融交易、高频交易）。
- 大堆内存（TB 级）应用。

### **JVM 参数**
```bash
-XX:+UseZGC  # 启用 ZGC（Java 11+）
```

---

## **6. Shenandoah GC**
### **特点**
- **类似 ZGC**：超低延迟（<10ms），并发整理。
- **使用转发指针（Forward Pointer）**：通过写屏障实现并发移动对象。
- **RedHat 开发**：Java 12+ 实验性支持，Java 15+ 正式功能。

### **适用场景**
- 与 ZGC 类似，但可能在某些场景下性能更优。

### **JVM 参数**
```bash
-XX:+UseShenandoahGC  # 启用 Shenandoah（需支持版本）
```

---

## **7. Epsilon GC**
### **特点**
- **无实际回收**：仅分配内存，不触发垃圾回收。
- **测试用途**：用于性能分析或内存泄漏测试。
- **极低开销**：几乎无 GC 停顿。

### **JVM 参数**
```bash
-XX:+UseEpsilonGC  # 启用 Epsilon（Java 11+）
```

---

## **8. 收集器组合对比**
| 收集器          | 新生代算法       | 老年代算法       | 目标场景                     | 停顿时间       |
|-----------------|------------------|------------------|------------------------------|----------------|
| Serial GC       | 复制             | 标记-整理        | 单核 CPU                     | 长（STW）     |
| Parallel GC     | 复制             | 标记-整理        | 高吞吐量                     | 中（STW）     |
| CMS             | 复制             | 标记-清除        | 低延迟（已废弃）             | 短（并发）    |
| G1              | 复制 + 标记-整理 | 标记-整理        | 大堆 + 可预测停顿            | 短（可控）    |
| ZGC / Shenandoah| 并发复制         | 并发整理         | 超低延迟 + 大堆              | 极短（<10ms） |

---

## **9. 如何选择垃圾收集器？**
1. **默认选择**：
   - Java 8：`-XX:+UseParallelGC`（服务器模式）。
   - Java 9+：`-XX:+UseG1GC`（推荐）。
2. **低延迟需求**：
   - 小堆（<4GB）：G1。
   - 大堆（>4GB）：ZGC 或 Shenandoah。
3. **高吞吐量需求**：
   - Parallel GC（允许较长 STW）。
4. **特殊场景**：
   - 测试/分析：Epsilon。
   - 嵌入式设备：Serial GC。

---

## **10. 监控与调优**
- **GC 日志**：
  ```bash
  -Xlog:gc*:file=gc.log:time,uptime,level,tags:filecount=5,filesize=10M
  ```
- **工具**：
  - `jstat -gc <pid>`：实时监控 GC 统计。
  - VisualVM、JConsole、GCEasy（日志分析）。
- **关键指标**：
  - 吞吐量（Application Time / Total Time）。
  - 最大停顿时间（Max Pause Time）。
  - 内存占用（Footprint）。

---

## **总结**
- **Java 8 及之前**：Parallel GC（默认）或 CMS（低延迟）。
- **Java 9+**：优先选择 G1 GC（平衡吞吐量与延迟）。
- **Java 11+**：超低延迟场景尝试 ZGC 或 Shenandoah。
- **避免过度调优**：先通过监控定位问题，再针对性优化。

根据应用特点（延迟敏感、吞吐量优先、堆大小）和 JVM 版本选择合适的收集器，并通过实际测试验证效果。
