# 什么是限流？限流算法有哪些？怎么实现的？

**难度**：中等

**创建时间**：2025-10-06 15:45:36

## 答案
限流（Rate Limiting）是系统保护的重要手段，通过控制单位时间内请求的访问量，防止资源过载、服务崩溃或数据被恶意刷爆。其核心目标是保障系统稳定性，同时兼顾用户体验。以下是限流的详细解析：

### **一、限流的核心作用**
1. **防止过载**：避免突发流量击垮服务器（如秒杀场景）。
2. **公平分配**：确保每个用户/服务获得合理的资源配额。
3. **成本控制**：防止恶意请求或爬虫浪费计算资源。
4. **降级策略**：在系统高峰期主动限制非核心功能。

### **二、常见限流算法及实现**
#### **1. 固定窗口算法（Fixed Window）**
- **原理**：将时间划分为固定窗口（如每秒1个窗口），每个窗口内计数器记录请求数，超过阈值则拒绝。
- **实现**：
  ```python
  class FixedWindow:
      def __init__(self, limit, window_size_sec):
          self.limit = limit
          self.window = window_size_sec
          self.counters = {}

      def allow_request(self, key):
          now = time.time()
          window_start = int(now / self.window) * self.window
          if key not in self.counters or self.counters[key] < window_start:
              self.counters[key] = window_start
              count = 0
          else:
              count = self.counters[key] - window_start
          
          if count < self.limit:
              self.counters[key] = window_start + count + 1
              return True
          return False
  ```
- **问题**：窗口边界可能突发流量（如两个窗口交界处允许2倍阈值请求）。

#### **2. 滑动窗口算法（Sliding Window）**
- **原理**：动态跟踪最近N个窗口的请求总和，避免固定窗口的边界问题。
- **实现**：
  ```python
  class SlidingWindow:
      def __init__(self, limit, window_size_sec):
          self.limit = limit
          self.window = window_size_sec
          self.requests = {}  # {timestamp: count}

      def allow_request(self, key):
          now = time.time()
          cutoff = now - self.window
          # 清理过期请求
          self.requests = {t: c for t, c in self.requests.items() if t > cutoff}
          # 计算当前窗口请求数
          current_count = sum(c for t, c in self.requests.items() if t >= cutoff)
          if current_count < self.limit:
              self.requests[now] = self.requests.get(now, 0) + 1
              return True
          return False
  ```
- **优化**：使用时间戳队列或Redis的ZSET存储请求时间，按时间排序后快速计算。

#### **3. 漏桶算法（Leaky Bucket）**
- **原理**：请求以固定速率处理，超出容量的请求排队或丢弃（平滑突发流量）。
- **实现**：
  ```python
  class LeakyBucket:
      def __init__(self, rate, capacity):
          self.rate = rate  # 每秒处理请求数
          self.capacity = capacity
          self.water = 0
          self.last_time = time.time()

      def allow_request(self):
          now = time.time()
          elapsed = now - self.last_time
          # 计算漏出的水量
          leaked = elapsed * self.rate
          self.water = max(0, self.water - leaked)
          self.last_time = now

          if self.water < self.capacity:
              self.water += 1
              return True
          return False
  ```
- **特点**：强制请求速率恒定，适合需要严格速率控制的场景（如API调用）。

#### **4. 令牌桶算法（Token Bucket）**
- **原理**：桶中以固定速率生成令牌，请求需获取令牌才能通过（允许一定突发）。
- **实现**：
  ```python
  class TokenBucket:
      def __init__(self, rate, capacity):
          self.rate = rate  # 每秒生成令牌数
          self.capacity = capacity
          self.tokens = capacity
          self.last_time = time.time()

      def allow_request(self):
          now = time.time()
          elapsed = now - self.last_time
          # 计算新增的令牌
          new_tokens = elapsed * self.rate
          self.tokens = min(self.capacity, self.tokens + new_tokens)
          self.last_time = now

          if self.tokens >= 1:
              self.tokens -= 1
              return True
          return False
  ```
- **特点**：允许短期突发流量（如桶容量为10，速率1个/秒，可瞬间处理10个请求）。

### **三、分布式限流实现**
在分布式系统中，需使用集中式存储（如Redis）协调限流状态：
1. **Redis + Lua脚本**：
   - **固定窗口**：用`INCR`和`EXPIRE`实现。
   - **滑动窗口**：用`ZADD`和`ZRANGEBYSCORE`统计时间窗口内请求。
   - **令牌桶**：用`DECR`和`EXPIRE`模拟令牌消耗。
   ```lua
   -- Redis令牌桶示例
   local key = KEYS[1]
   local rate = tonumber(ARGV[1])  -- 每秒令牌数
   local capacity = tonumber(ARGV[2])
   local now = tonumber(ARGV[3])

   local last_time = redis.call("HGET", key, "last_time")
   last_time = last_time and tonumber(last_time) or now
   local tokens = redis.call("HGET", key, "tokens")
   tokens = tokens and tonumber(tokens) or capacity

   local elapsed = now - last_time
   local new_tokens = math.min(capacity, tokens + elapsed * rate)
   redis.call("HSET", key, "last_time", now)
   redis.call("HSET", key, "tokens", new_tokens)

   if new_tokens >= 1 then
       redis.call("HSET", key, "tokens", new_tokens - 1)
       return 1
   else
       return 0
   end
   ```

2. **Sentinel或Gateway集成**：
   - 使用Nginx的`limit_req_module`或Spring Cloud Gateway的`RequestRateLimiter`。

### **四、算法选择建议**
- **固定窗口**：简单场景，对精度要求不高。
- **滑动窗口**：需要更精确的流量控制。
- **漏桶**：强制平滑流量（如视频流处理）。
- **令牌桶**：允许突发流量（如用户登录接口）。

### **五、实践中的注意事项**
1. **动态阈值**：根据系统负载动态调整限流阈值（如CPU使用率）。
2. **多级限流**：结合全局、接口、用户级限流。
3. **降级策略**：限流时返回友好提示（如`429 Too Many Requests`）或重试机制。
4. **监控与告警**：实时监控限流触发次数，及时调整策略。

通过合理选择限流算法和实现方式，可以显著提升系统的稳定性和可靠性。
