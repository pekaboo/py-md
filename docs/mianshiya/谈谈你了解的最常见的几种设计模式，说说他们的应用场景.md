# 谈谈你了解的最常见的几种设计模式，说说他们的应用场景

**难度**：中等

**创建时间**：2025-10-05 12:11:35

## 答案
设计模式是解决特定软件设计问题的可复用方案，能够提升代码的可维护性、扩展性和复用性。以下是几种最常见的设计模式及其典型应用场景，结合实际开发中的案例进行说明：

---

### 1. **单例模式（Singleton）**
#### **核心思想**  
确保一个类只有一个实例，并提供全局访问点。

#### **应用场景**  
- **全局配置管理**：如数据库连接池、线程池、日志管理器等需要全局唯一实例的场景。  
- **缓存系统**：避免重复创建缓存对象，节省内存。  
- **配置类**：如系统配置、环境变量等需要单次加载后全局使用的场景。  

#### **代码示例（Java）**  
```java
public class DatabasePool {
    private static volatile DatabasePool instance;
    
    private DatabasePool() {} // 私有构造方法
    
    public static DatabasePool getInstance() {
        if (instance == null) {
            synchronized (DatabasePool.class) {
                if (instance == null) {
                    instance = new DatabasePool();
                }
            }
        }
        return instance;
    }
}
```

#### **优点**  
- 控制资源访问，避免重复创建开销。  
- 提供全局唯一访问点。  

#### **缺点**  
- 多线程环境下需处理同步问题（如双重检查锁）。  
- 过度使用可能导致代码耦合度高。  

---

### 2. **工厂模式（Factory）**
#### **核心思想**  
通过工厂类创建对象，而非直接调用构造方法，解耦对象创建与使用。

#### **应用场景**  
- **对象创建复杂**：如需要初始化多个依赖或配置的对象（如数据库连接、网络请求）。  
- **多类型对象管理**：如支付系统支持多种支付方式（支付宝、微信、银行卡），通过工厂统一创建。  
- **框架设计**：如Spring的`BeanFactory`通过配置动态创建Bean。  

#### **代码示例（Java）**  
```java
// 接口定义
public interface Payment {
    void pay(double amount);
}

// 具体实现类
public class Alipay implements Payment {
    @Override
    public void pay(double amount) {
        System.out.println("使用支付宝支付：" + amount);
    }
}

// 工厂类
public class PaymentFactory {
    public static Payment createPayment(String type) {
        if ("alipay".equals(type)) {
            return new Alipay();
        } else if ("wechat".equals(type)) {
            return new WechatPay();
        }
        throw new IllegalArgumentException("不支持的支付方式");
    }
}
```

#### **优点**  
- 降低代码耦合度，便于扩展新类型。  
- 统一管理对象创建逻辑。  

#### **缺点**  
- 增加类数量，可能使结构复杂化。  

---

### 3. **观察者模式（Observer）**
#### **核心思想**  
定义对象间的一对多依赖关系，当一个对象状态变化时，自动通知所有依赖它的对象。

#### **应用场景**  
- **事件驱动系统**：如GUI按钮点击事件、Android的BroadcastReceiver。  
- **消息通知**：如订单状态变更时通知用户、物流系统。  
- **发布-订阅模型**：如Kafka、RocketMQ的消息生产与消费。  

#### **代码示例（Java）**  
```java
// 主题接口
public interface Subject {
    void registerObserver(Observer o);
    void notifyObservers(String message);
}

// 观察者接口
public interface Observer {
    void update(String message);
}

// 具体实现
public class NewsPublisher implements Subject {
    private List<Observer> observers = new ArrayList<>();
    
    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }
    
    @Override
    public void notifyObservers(String message) {
        for (Observer o : observers) {
            o.update(message);
        }
    }
}

public class User implements Observer {
    @Override
    public void update(String message) {
        System.out.println("收到通知：" + message);
    }
}
```

#### **优点**  
- 动态解耦发布者与订阅者。  
- 支持广播式通知。  

#### **缺点**  
- 观察者过多可能导致性能问题。  
- 通知顺序不可控。  

---

### 4. **策略模式（Strategy）**
#### **核心思想**  
定义一系列算法，封装每个算法，并使它们可互换。

#### **应用场景**  
- **算法多变**：如排序算法（冒泡、快速、归并）、压缩算法（ZIP、RAR）。  
- **支付方式选择**：如电商系统支持多种支付策略（优惠券、积分、现金）。  
- **游戏AI行为**：如敌人根据不同策略攻击（近战、远程、逃跑）。  

#### **代码示例（Java）**  
```java
// 策略接口
public interface SortStrategy {
    void sort(int[] array);
}

// 具体策略
public class QuickSort implements SortStrategy {
    @Override
    public void sort(int[] array) {
        // 快速排序实现
    }
}

public class BubbleSort implements SortStrategy {
    @Override
    public void sort(int[] array) {
        // 冒泡排序实现
    }
}

// 上下文类
public class Sorter {
    private SortStrategy strategy;
    
    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void executeSort(int[] array) {
        strategy.sort(array);
    }
}
```

#### **优点**  
- 避免条件语句，易于扩展新算法。  
- 运行时动态切换策略。  

#### **缺点**  
- 增加类数量，需提前定义所有策略。  

---

### 5. **装饰器模式（Decorator）**
#### **核心思想**  
动态地给对象添加额外的职责，比继承更灵活。

#### **应用场景**  
- **功能扩展**：如Java I/O流（`BufferedReader`装饰`FileReader`）、GUI组件（边框、滚动条）。  
- **AOP编程**：如日志、事务等横切关注点的动态添加。  
- **饮品定制**：如星巴克咖啡（基础咖啡+奶泡+巧克力）。  

#### **代码示例（Java）**  
```java
// 组件接口
public interface Coffee {
    double cost();
    String description();
}

// 具体组件
public class SimpleCoffee implements Coffee {
    @Override
    public double cost() {
        return 10;
    }
    
    @Override
    public String description() {
        return "简单咖啡";
    }
}

// 装饰器基类
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }
    
    @Override
    public double cost() {
        return decoratedCoffee.cost();
    }
    
    @Override
    public String description() {
        return decoratedCoffee.description();
    }
}

// 具体装饰器
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public double cost() {
        return super.cost() + 2;
    }
    
    @Override
    public String description() {
        return super.description() + "+牛奶";
    }
}
```

#### **优点**  
- 动态扩展功能，无需修改原有类。  
- 支持多层装饰。  

#### **缺点**  
- 增加对象数量，可能使结构复杂化。  

---

### 6. **代理模式（Proxy）**
#### **核心思想**  
为其他对象提供代理以控制对它的访问。

#### **应用场景**  
- **远程调用**：如RPC框架（Dubbo、gRPC）通过代理隐藏网络细节。  
- **权限控制**：如管理员操作需通过代理验证权限。  
- **性能优化**：如缓存代理（Redis缓存数据库查询结果）。  

#### **代码示例（Java）**  
```java
// 接口定义
public interface Image {
    void display();
}

// 真实对象
public class RealImage implements Image {
    private String filename;
    
    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk(); // 耗时操作
    }
    
    private void loadFromDisk() {
        System.out.println("加载图片：" + filename);
    }
    
    @Override
    public void display() {
        System.out.println("显示图片：" + filename);
    }
}

// 代理类
public class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;
    
    public ProxyImage(String filename) {
        this.filename = filename;
    }
    
    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}
```

#### **优点**  
- 控制访问权限，隐藏复杂初始化。  
- 支持虚拟代理（延迟加载）、保护代理（权限控制）等。  

#### **缺点**  
- 增加代理类，可能使调用链变长。  

---

### 总结
| 设计模式   | 核心目的                     | 典型应用场景                          |
|------------|------------------------------|---------------------------------------|
| 单例模式   | 确保唯一实例                 | 配置管理、缓存系统                    |
| 工厂模式   | 解耦对象创建                 | 支付系统、框架设计                    |
| 观察者模式 | 事件通知与解耦               | GUI事件、消息队列                     |
| 策略模式   | 动态切换算法                 | 排序算法、支付策略                    |
| 装饰器模式 | 动态扩展功能                 | Java I/O流、GUI组件                   |
| 代理模式   | 控制访问权限                 | RPC调用、权限控制                     |

根据具体业务需求选择合适的设计模式，能够显著提升代码的可维护性和扩展性。例如，在电商系统中，可结合**工厂模式**管理支付方式、**策略模式**实现优惠券计算、**观察者模式**通知订单状态变更，从而构建高可用的架构。
