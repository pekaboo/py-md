# 什么是循环依赖（常问）？

**难度**：中等

**创建时间**：2025-10-06 15:43:58

## 答案
### **什么是循环依赖？**
循环依赖（Circular Dependency）是指**两个或多个类、模块或组件之间相互依赖，形成闭环**，导致系统无法正常初始化或运行。它是一种常见的软件设计问题，尤其在依赖注入（DI）、对象创建或模块加载时容易发生。

---

### **循环依赖的常见场景**
#### 1. **类之间的循环依赖**
**示例**：  
类A依赖类B，类B又依赖类A，形成闭环。
```java
// 类A依赖类B
public class A {
    private B b;
    public A(B b) { this.b = b; }
}

// 类B依赖类A
public class B {
    private A a;
    public B(A a) { this.a = a; }
}

// 初始化时无法完成：
// 创建A需要B，创建B又需要A，形成死循环
A a = new A(new B(a)); // 编译错误：a未初始化
```

#### 2. **Spring中的Bean循环依赖**
在Spring框架中，若两个Bean通过`@Autowired`或构造函数注入相互依赖，会触发循环依赖问题。
```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB; // ServiceA依赖ServiceB
}

@Service
public class ServiceB {
    @Autowired
    private ServiceA serviceA; // ServiceB依赖ServiceA
}
```
**问题**：Spring容器在初始化`ServiceA`时需要`ServiceB`，而`ServiceB`又需要`ServiceA`，导致初始化失败。

#### 3. **模块/组件间的循环依赖**
模块A调用模块B的功能，模块B又调用模块A的功能，形成闭环。
```
模块A → 模块B → 模块A
```
**后果**：模块加载时可能因依赖顺序问题崩溃，或运行时出现不可预测的行为。

---

### **循环依赖的危害**
1. **初始化失败**：对象无法被正确构造，导致`NullPointerException`或启动失败。
2. **性能问题**：反复尝试初始化可能引发无限循环或资源耗尽。
3. **代码可维护性差**：循环依赖通常意味着设计耦合度过高，违反单一职责原则。
4. **测试困难**：单元测试时需模拟整个闭环，增加测试复杂度。

---

### **如何解决循环依赖？**
#### 1. **重构设计（推荐）**
- **提取公共逻辑**：将循环依赖的部分抽离为第三个类或接口。
  ```java
  // 原始循环依赖
  class A { void methodA() { b.methodB(); } }
  class B { void methodB() { a.methodA(); } }

  // 重构后：引入中介类C
  class C { 
      public void execute() { 
          // 封装A和B的交互逻辑
      }
  }
  ```
- **依赖倒置**：通过接口或抽象类解耦具体实现。
  ```java
  interface IA { void methodA(); }
  interface IB { void methodB(); }

  class A implements IA {
      private IB b;
      public A(IB b) { this.b = b; }
      public void methodA() { b.methodB(); }
  }

  class B implements IB {
      private IA a;
      public B(IA a) { this.a = a; }
      public void methodB() { a.methodA(); }
  }
  ```

#### 2. **使用Setter/方法注入（Spring场景）**
Spring默认通过构造函数注入，若存在循环依赖，可改用`@Autowired`字段注入或Setter注入，利用Spring的三级缓存机制解决。
```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB; // 字段注入允许延迟依赖
}

@Service
public class ServiceB {
    @Autowired
    private ServiceA serviceA; // 字段注入允许延迟依赖
}
```
**原理**：Spring会先创建Bean的早期引用（未完全初始化），放入三级缓存，供其他Bean依赖。

#### 3. **引入中间层**
通过消息队列、事件总线或服务层解耦直接依赖。
```
模块A → 事件总线 ← 模块B
```

#### 4. **使用代理或懒加载**
- **代理模式**：通过代理对象延迟实际依赖的初始化。
- **懒加载（Lazy Initialization）**：在首次使用时才初始化依赖。
  ```java
  public class A {
      private Lazy<B> b; // 懒加载B
      public A() { this.b = new Lazy<>(() -> new B(this)); }
  }
  ```

---

### **Spring中循环依赖的特殊处理**
Spring通过**三级缓存**解决部分循环依赖（仅限单例Bean且通过Setter/方法注入）：
1. **一级缓存（SingletonObjects）**：存放完全初始化的Bean。
2. **二级缓存（EarlySingletonObjects）**：存放已创建但未填充属性的Bean。
3. **三级缓存（SingletonFactories）**：存放Bean工厂对象（用于生成代理）。

**流程**：
1. 初始化`ServiceA`时，将其工厂对象放入三级缓存。
2. 初始化`ServiceB`时，从三级缓存获取`ServiceA`的早期引用（未完全初始化）。
3. `ServiceB`初始化完成后，`ServiceA`再完成自身初始化。

**限制**：
- 仅支持单例Bean。
- 构造函数注入无法解决（因必须完全初始化后才能暴露引用）。

---

### **预防循环依赖的最佳实践**
1. **遵循单一职责原则**：每个类/模块只做一件事，减少依赖。
2. **依赖注入方向**：高层模块依赖低层模块，避免反向依赖。
3. **使用接口隔离**：通过接口定义依赖，降低具体实现的耦合。
4. **代码审查**：通过静态分析工具（如SonarQube）检测循环依赖。

---

### **总结**
| **问题**         | **解决方案**                          | **适用场景**                     |
|------------------|---------------------------------------|----------------------------------|
| 类间循环依赖     | 重构设计、引入中间类                  | 通用Java开发                     |
| Spring Bean循环  | Setter注入、懒加载、三级缓存          | Spring框架项目                   |
| 模块间循环依赖   | 事件总线、消息队列、服务层解耦        | 大型分布式系统                   |

**核心原则**：循环依赖本质是设计问题的体现，优先通过重构解耦，而非依赖框架特性临时解决。
