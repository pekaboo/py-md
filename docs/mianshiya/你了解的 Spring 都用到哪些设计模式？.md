# 你了解的 Spring 都用到哪些设计模式？

**难度**：中等

**创建时间**：2025-10-06 05:57:11

## 答案
Spring框架中广泛应用了多种设计模式，以实现其强大的功能、灵活性和可维护性。以下是Spring中常用的设计模式及其应用场景：

### 1. **工厂模式（Factory Pattern）**

* **应用场景**：Spring通过`BeanFactory`和`ApplicationContext`等接口创建并管理对象实例。
* **实现方式**：`BeanFactory`是一个工厂接口，提供了获取Bean对象的方法（如`getBean(String name)`）。`ApplicationContext`是`BeanFactory`的子接口，提供了更多高级功能，如国际化、事件传播和自动Bean注入等。
* **优势**：将对象的创建逻辑封装在工厂类中，通过配置文件或注解来定义对象的创建方式和依赖关系，实现了对象创建与使用的解耦。

### 2. **单例模式（Singleton Pattern）**

* **应用场景**：Spring框架中的Bean默认是单例的，即在容器中只有一个实例。
* **实现方式**：Spring容器启动时，会为每个作用域为`singleton`的Bean创建并维护一个单实例对象，这些对象会被存储在一个缓存中，从而确保每次注入时都是同一个实例。
* **优势**：有助于节省系统资源，避免不必要的对象重复创建和销毁开销。

### 3. **代理模式（Proxy Pattern）**

* **应用场景**：Spring的AOP（面向切面编程）功能大量使用了代理模式。
* **实现方式**：Spring提供了两种代理方式：JDK动态代理和CGLIB代理。如果目标类实现了一个接口，Spring默认使用JDK动态代理；如果没有实现接口，则使用CGLIB来生成子类代理。
* **优势**：允许在不修改目标对象源代码的情况下，为目标对象添加额外的功能，如日志记录、事务管理、安全验证等横切关注点。

### 4. **模板方法模式（Template Method Pattern）**

* **应用场景**：用于定义一个操作的算法骨架，将一些步骤推迟到子类中去实现。
* **实现方式**：Spring框架在JDBC、Hibernate、JPA、事务管理等模块中都使用了模板方法模式。例如，`JdbcTemplate`类使用模板方法模式来封装与数据库交互的步骤。开发者只需提供SQL语句和参数，而不必关心资源获取、异常处理和资源释放等细节。
* **优势**：复用资源管理（如连接获取/释放）等通用逻辑，允许子类只关注业务差异（如结果映射）。

### 5. **观察者模式（Observer Pattern）**

* **应用场景**：Spring框架中的事件驱动机制使用了观察者模式。
* **实现方式**：`ApplicationEventPublisher`是一个事件发布者，`ApplicationListener`是一个事件监听器。Spring容器允许多个监听器订阅和监听特定类型的事件，当事件发生时，所有订阅的监听器都会收到通知。
* **优势**：事件源与监听器完全解耦，支持异步处理（加`@Async`注解即可）。

### 6. **策略模式（Strategy Pattern）**

* **应用场景**：用于定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。
* **实现方式**：Spring框架在很多地方使用策略模式，例如在事务管理中使用不同的事务管理策略（如JDBC、JTA），在视图解析器（`ViewResolver`）中使用不同的视图解析策略（如JSP、Thymeleaf）。
* **优势**：让算法独立于使用它的客户而变化，提高了代码的可拓展性，降低了耦合度。

### 7. **适配器模式（Adapter Pattern）**

* **应用场景**：用于将一个接口转换为客户希望的另一个接口。
* **实现方式**：在Spring MVC中，`HandlerAdapter`用于将不同的处理器（`Handler`）适配为统一的接口。例如，`HttpRequestHandlerAdapter`和`SimpleControllerHandlerAdapter`分别适配`HttpRequestHandler`和`Controller`，使得Spring MVC可以支持多种不同类型的控制器。
* **优势**：兼容不兼容的接口，提高系统的灵活性和可扩展性。

### 8. **装饰器模式（Decorator Pattern）**

* **应用场景**：用于动态地为对象添加行为而不改变其结构。
* **实现方式**：在Spring AOP中，代理对象（代理类）就是对目标对象的增强（装饰），可以动态地为目标对象添加新的行为（如方法拦截、日志记录、事务管理等）。
* **优势**：相比生成子类，装饰器模式在增加功能时更为灵活。
