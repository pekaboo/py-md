# 为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？

**难度**：中等

**创建时间**：2025-10-06 06:01:31

## 答案
在 Java 中，`HashMap` 扩容时采用 **2 的 n 次方（2^n）** 作为新容量，这一设计主要基于以下几个关键原因，旨在优化哈希表的性能和数据分布的均匀性：

---

### **1. 哈希冲突的最小化**
`HashMap` 通过哈希函数（`hashCode()`）计算键的哈希值，然后通过取模运算（`hash & (n-1)`，其中 `n` 是容量）确定键值对在数组中的索引。**选择 2 的幂次方作为容量时，`n-1` 的二进制表示会全为 1**（例如，容量为 16 时，`n-1 = 15`，二进制为 `1111`）。此时：
- **取模运算等价于按位与运算**：`hash % n == hash & (n-1)`。  
  按位与运算的效率远高于取模运算（CPU 指令级优化），能显著提升哈希定位的速度。
- **均匀分布**：无论哈希值的低位如何，`hash & (n-1)` 都能均匀覆盖所有索引，避免因容量非 2 的幂次方导致高位信息丢失，从而减少哈希冲突。

**反例**：若容量为 10（非 2 的幂次方），`n-1 = 9`（二进制 `1001`），则哈希值的低位 `001` 会被固定保留，而高位可能被忽略，导致某些索引（如 0、1、8、9）被频繁占用，其他索引空闲，冲突率上升。

---

### **2. 扩容时的快速重新哈希**
当 `HashMap` 扩容时，需要将旧数组中的键值对重新映射到新数组。如果新容量是旧容量的 2 倍（即 `2^n`），则：
- **索引计算简化**：新索引只需在原索引基础上增加一个高位（`hash & (newCapacity - 1)`）。  
  例如，旧容量为 16（索引范围 `0-15`），新容量为 32（索引范围 `0-31`）。若原索引为 `i`，新索引可能是 `i` 或 `i + 16`（取决于哈希值的最高位是否为 1）。这种规则使得重新哈希的效率极高。
- **避免遍历所有键值对**：无需重新计算所有键的完整哈希值，仅需检查哈希值的最高位即可确定新索引，时间复杂度从 `O(n)` 降低到接近 `O(1)`。

---

### **3. 链表或红黑树的均衡分布**
`HashMap` 在同一个索引（桶）中通过链表或红黑树存储冲突的键值对。若容量非 2 的幂次方，可能导致：
- **桶的负载不均衡**：某些桶的键值对数量远多于其他桶，增加查询时间（链表需遍历，红黑树需旋转）。
- **红黑树触发条件失效**：`HashMap` 在链表长度超过 8 且桶数量大于 64 时会转为红黑树。若容量非 2 的幂次方，可能导致某些桶过早或过晚触发转换，影响性能。

---

### **4. 源码中的关键实现**
在 `HashMap` 的源码中，扩容逻辑（`resize()` 方法）和索引计算（`hash()` 方法）均体现了这一设计：
```java
// 计算索引的哈希函数（JDK 8+）
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    // 高16位与低16位异或，减少高位信息丢失
}

// 扩容条件：元素数量 >= 容量 * 负载因子（默认0.75）
if (++size > threshold)
    resize();

// 扩容后的新容量为旧容量的2倍（不超过最大值）
newCap = oldCap << 1;
```

---

### **5. 为什么不是其他质数？**
传统哈希表设计（如链地址法）可能建议使用质数作为容量以减少冲突，但：
- **性能权衡**：质数的取模运算（`%`）比按位与运算（`&`）慢得多，尤其在频繁插入/查询时。
- **动态扩容**：`HashMap` 需要动态调整容量，而质数的 2 倍可能不再是质数（如 7 → 14），导致重新计算容量的复杂度增加。

---

### **总结**
| 设计原因                | 具体优势                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| **按位与替代取模**      | 提升索引计算速度（CPU 指令优化）。                                        |
| **均匀分布哈希值**      | 减少哈希冲突，避免桶负载不均衡。                                          |
| **快速重新哈希**        | 扩容时仅需检查哈希值高位，时间复杂度接近 `O(1)`。                        |
| **链表/红黑树优化**      | 保证冲突处理的高效性（链表遍历或红黑树旋转）。                            |

这一设计是 Java 在 **时间效率**（哈希计算、扩容）和 **空间效率**（均匀分布）之间的权衡结果，也是 `HashMap` 高性能的核心原因之一。
