# 说说 Java 中 HashMap 的原理？

**难度**：中等

**创建时间**：2025-10-02 12:41:44

## 答案
# Java中HashMap的原理

HashMap是Java集合框架中非常重要的数据结构，它基于哈希表实现，提供了高效的键值对存储和检索功能。下面是HashMap的核心原理：

## 基本结构

1. **数组+链表+红黑树**：
   - HashMap内部使用一个`Node<K,V>[]`数组（称为"桶"或"bucket"）来存储数据
   - 每个数组元素是一个单向链表（JDK1.8之前）或链表/红黑树（JDK1.8及以后）
   - 当链表长度超过阈值（默认为8）时，链表会转换为红黑树

2. **核心参数**：
   - `capacity`：当前数组容量（默认16）
   - `loadFactor`：负载因子（默认0.75）
   - `threshold`：扩容阈值 = capacity × loadFactor

## 工作原理

### 1. 存储过程（put方法）

1. 计算键的哈希值：`hash = key.hashCode() ^ (key.hashCode() >>> 16)`
2. 确定数组索引：`index = (数组长度 - 1) & hash`
3. 如果该位置为空，直接插入新节点
4. 如果该位置有节点：
   - 如果key已存在，覆盖旧值
   - 如果key不存在，添加到链表尾部（JDK1.7）或头部（JDK1.8）
   - 如果链表长度≥8且数组长度≥64，转换为红黑树
5. 如果元素数量超过阈值，进行扩容（resize）

### 2. 检索过程（get方法）

1. 计算键的哈希值
2. 确定数组索引
3. 在对应位置的链表/红黑树中查找匹配的key
4. 找到则返回对应value，否则返回null

## 重要特性

1. **哈希冲突处理**：
   - 使用链地址法（相同hash的元素存入链表）
   - JDK1.8后对链表长度超过8的情况使用红黑树优化

2. **扩容机制**：
   - 当元素数量 > capacity × loadFactor时触发
   - 扩容为原来的2倍
   - 重新计算所有元素的索引（rehash）

3. **线程不安全**：
   - HashMap不是线程安全的
   - 多线程环境下可能导致死循环（JDK1.7）或数据不一致
   - 线程安全版本：ConcurrentHashMap或Collections.synchronizedMap

## 性能分析

- 理想情况（无冲突）：O(1)时间复杂度
- 最坏情况（所有元素哈希冲突）：O(n)（链表）或O(log n)（红黑树）

## JDK1.8优化

1. 链表头插改为尾插（避免扩容时死循环）
2. 引入红黑树提高冲突时的查询效率
3. 扩容时元素位置计算优化（利用高位哈希）

HashMap通过合理的哈希函数设计和动态扩容机制，在大多数情况下提供了高效的插入、删除和查找操作。
