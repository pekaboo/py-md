# 数据库的脏读、不可重复读和幻读分别是什么？

**难度**：中等

**创建时间**：2025-10-04 08:38:16

## 答案
数据库中的**脏读（Dirty Read）**、**不可重复读（Non-repeatable Read）**和**幻读（Phantom Read）**是并发事务操作中常见的三种数据一致性问题，它们与事务隔离级别密切相关。以下是它们的定义、区别及示例说明：

### **一、脏读（Dirty Read）**
**定义**：一个事务读取了另一个未提交事务修改过的数据。如果该事务后续回滚，则读取到的数据是“脏数据”（无效数据）。

**特点**：
- 发生在**读未提交（Read Uncommitted）**隔离级别下。
- 破坏了事务的**原子性**（事务未完成时数据不应被其他事务看到）。

**示例**：
1. 事务A修改数据（如将`balance`从100改为50），但未提交。
2. 事务B读取到`balance=50`。
3. 事务A回滚，`balance`恢复为100。
4. 事务B基于错误的`balance=50`进行后续操作，导致数据不一致。

**解决方案**：
- 将隔离级别提升至**读已提交（Read Committed）**或更高。

### **二、不可重复读（Non-repeatable Read）**
**定义**：在同一事务内，多次读取同一数据时，由于其他事务的修改，导致前后读取的结果不一致。

**特点**：
- 发生在**读已提交（Read Committed）**隔离级别下。
- 破坏了事务的**隔离性**（事务内多次读取应看到相同数据）。
- 与脏读的区别：不可重复读读取的是已提交的数据，但数据在事务内被修改。

**示例**：
1. 事务A首次读取`user.age=20`。
2. 事务B修改`user.age=21`并提交。
3. 事务A再次读取`user.age`，得到`21`（与第一次结果不同）。

**解决方案**：
- 将隔离级别提升至**可重复读（Repeatable Read）**或更高。

### **三、幻读（Phantom Read）**
**定义**：在同一事务内，多次执行相同的查询条件时，由于其他事务的插入或删除操作，导致返回的行数不一致（如第一次查询返回5行，第二次返回6行）。

**特点**：
- 发生在**可重复读（Repeatable Read）**隔离级别下（MySQL的InnoDB引擎通过多版本并发控制（MVCC）和间隙锁（Gap Lock）部分避免幻读，但标准SQL中仍可能发生）。
- 破坏了事务的**一致性**（事务内查询结果应稳定）。
- 与不可重复读的区别：幻读针对的是“行数变化”，而不可重复读针对的是“单行数据变化”。

**示例**：
1. 事务A查询`age > 18`的用户，返回5行。
2. 事务B插入一条`age=19`的记录并提交。
3. 事务A再次查询`age > 18`的用户，返回6行（多出一行）。

**解决方案**：
- 将隔离级别提升至**串行化（Serializable）**（最高隔离级别，但性能最低）。
- 在MySQL中，可通过**间隙锁（Gap Lock）**或**临键锁（Next-Key Lock）**避免幻读（需结合具体查询条件）。

### **四、三者的对比总结**
| **问题类型**   | **发生场景**                     | **隔离级别**               | **影响**                          | **示例**                                      |
|----------------|----------------------------------|----------------------------|-----------------------------------|-----------------------------------------------|
| **脏读**       | 读取未提交数据                   | 读未提交（Read Uncommitted） | 数据无效（事务回滚后）            | 事务A回滚后，事务B基于错误数据操作             |
| **不可重复读** | 同一事务内多次读取同一数据结果不同 | 读已提交（Read Committed）   | 数据修改导致结果不一致            | 事务A两次读取`user.age`，值从20变为21         |
| **幻读**       | 同一事务内多次查询返回行数不同   | 可重复读（Repeatable Read） | 插入/删除导致行数变化             | 事务A两次查询`age>18`的用户，行数从5变为6     |

### **五、事务隔离级别与问题的关系**
| **隔离级别**               | **脏读** | **不可重复读** | **幻读** | **性能** |
|----------------------------|----------|----------------|----------|----------|
| 读未提交（Read Uncommitted）| 可能     | 可能           | 可能     | 最高     |
| 读已提交（Read Committed）  | 不可能   | 可能           | 可能     | 高       |
| 可重复读（Repeatable Read） | 不可能   | 不可能         | 可能*    | 中       |
| 串行化（Serializable）      | 不可能   | 不可能         | 不可能   | 最低     |

> *注：MySQL的InnoDB引擎通过MVCC和间隙锁在可重复读级别下避免了幻读，但标准SQL中可能仍存在。

### **六、实际应用建议**
1. **根据业务需求选择隔离级别**：
   - 高并发场景：优先选择**读已提交**（平衡性能与一致性）。
   - 金融等严格场景：选择**可重复读**或**串行化**。
2. **使用锁机制**：
   - 对关键数据显式加锁（如`SELECT ... FOR UPDATE`）。
3. **优化事务设计**：
   - 缩短事务执行时间，减少锁竞争。
   - 避免长事务和频繁提交。
