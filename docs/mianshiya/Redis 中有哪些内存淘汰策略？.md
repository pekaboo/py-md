# Redis 中有哪些内存淘汰策略？

**难度**：中等

**创建时间**：2025-10-06 15:39:55

## 答案
Redis 的内存淘汰策略（Eviction Policies）用于在内存达到上限（`maxmemory`）时，自动删除部分数据以释放空间，从而保证服务继续运行。Redis 提供了 **8 种淘汰策略**，分为 **不淘汰数据**、**随机淘汰**、**LRU 淘汰**、**LFU 淘汰** 和 **TTL 淘汰** 五大类。以下是详细说明：

---

### **1. 内存淘汰策略分类**
#### **（1）不淘汰数据（No Eviction）**
- **策略名**：`noeviction`  
- **行为**：当内存达到上限时，**拒绝所有写入请求**（如 `SET`、`LPUSH` 等），但允许读取和删除操作。  
- **适用场景**：对数据一致性要求极高，不允许丢失任何数据的场景（如缓存绝对不可丢的配置）。  
- **风险**：可能导致写入请求失败，需配合监控和扩容。

#### **（2）随机淘汰（Random）**
- **策略名**：  
  - `random`：从所有键中随机删除一个键。  
  - `volatile-random`：仅从设置了过期时间（TTL）的键中随机删除一个。  
- **行为**：随机选择键进行删除，无优先级考量。  
- **适用场景**：对数据访问模式无规律，且希望简单快速释放内存的场景。  
- **缺点**：可能误删热点数据。

#### **（3）LRU 淘汰（Least Recently Used）**
- **策略名**：  
  - `volatile-lru`：从设置了过期时间的键中，删除最近最少使用的键。  
  - `allkeys-lru`：从所有键中，删除最近最少使用的键。  
- **行为**：基于访问时间，优先淘汰长期未被访问的数据。  
- **实现原理**：Redis 使用近似 LRU 算法（采样部分键进行淘汰，而非全局扫描），以平衡性能和准确性。  
- **适用场景**：缓存场景，希望保留最近频繁访问的数据（如热点数据）。  
- **缺点**：采样可能导致部分热点数据被误删。

#### **（4）LFU 淘汰（Least Frequently Used）**
- **策略名**：  
  - `volatile-lfu`：从设置了过期时间的键中，删除访问频率最低的键。  
  - `allkeys-lfu`：从所有键中，删除访问频率最低的键。  
- **行为**：基于访问频率，优先淘汰访问次数最少的数据。  
- **实现原理**：Redis 4.0+ 引入，记录每个键的访问次数（`LFU counter`），按频率排序淘汰。  
- **适用场景**：数据访问频率差异大，希望保留高频访问数据的场景（如推荐系统）。  
- **优点**：比 LRU 更适合访问模式稳定的场景。

#### **（5）TTL 淘汰（Time To Live）**
- **策略名**：`volatile-ttl`  
- **行为**：从设置了过期时间的键中，优先删除剩余生存时间（TTL）最短的键。  
- **适用场景**：希望尽快释放即将过期的数据，减少内存占用。  
- **缺点**：可能误删未来可能被访问的短期数据。

---

### **2. 策略对比表**
| **策略名**               | **淘汰范围**               | **淘汰依据**       | **适用场景**                          |
|--------------------------|----------------------------|--------------------|---------------------------------------|
| `noeviction`             | 不淘汰                     | -                  | 禁止写入，保证数据不丢失              |
| `random`                 | 所有键或过期键             | 随机               | 简单快速释放内存                      |
| `volatile-random`        | 仅过期键                   | 随机               | 同上，但仅限过期键                    |
| `volatile-lru`           | 仅过期键                   | 最近最少使用       | 缓存，保留热点数据（过期键范围）      |
| `allkeys-lru`            | 所有键                     | 最近最少使用       | 缓存，保留热点数据（全局范围）        |
| `volatile-lfu`           | 仅过期键                   | 访问频率最低       | 访问模式稳定的场景（过期键范围）      |
| `allkeys-lfu`            | 所有键                     | 访问频率最低       | 访问模式稳定的场景（全局范围）        |
| `volatile-ttl`           | 仅过期键                   | 剩余TTL最短        | 尽快释放即将过期的数据                |

---

### **3. 配置方法**
#### **（1）设置内存上限**
在 Redis 配置文件（`redis.conf`）或运行时通过命令设置：
```bash
# 配置文件
maxmemory 1gb

# 运行时
CONFIG SET maxmemory 1gb
```

#### **（2）选择淘汰策略**
在配置文件或运行时设置：
```bash
# 配置文件
maxmemory-policy allkeys-lru

# 运行时
CONFIG SET maxmemory-policy allkeys-lru
```

#### **（3）查看当前策略**
```bash
CONFIG GET maxmemory-policy
# 输出示例： "maxmemory-policy", "allkeys-lru"
```

---

### **4. 策略选择建议**
| **场景**                          | **推荐策略**               | **理由**                                  |
|-----------------------------------|----------------------------|-------------------------------------------|
| 缓存热点数据，无过期时间          | `allkeys-lru` 或 `allkeys-lfu` | 保留高频访问数据，避免缓存击穿            |
| 缓存热点数据，有过期时间          | `volatile-lru` 或 `volatile-lfu` | 仅淘汰过期键，减少误删未过期数据的风险    |
| 尽快释放即将过期的数据            | `volatile-ttl`             | 适用于短周期缓存（如验证码、会话）        |
| 禁止写入，保证数据不丢失          | `noeviction`               | 关键业务数据（如金融、配置）              |
| 简单快速释放内存，无特殊需求      | `random` 或 `volatile-random` | 实现简单，性能开销低                      |

---

### **5. 注意事项**
1. **LRU/LFU 的近似性**：Redis 使用采样（默认 5 个键）而非全局扫描，可能误删部分热点数据。可通过 `maxmemory-samples` 调整采样数（如 `CONFIG SET maxmemory-samples 10`）。
2. **LFU 的计数器**：LFU 策略会记录访问频率，但频率计数器会随时间衰减（避免旧数据长期占用高频率）。
3. **持久化影响**：淘汰策略仅影响内存数据，若开启了 RDB/AOF 持久化，被淘汰的数据可能从磁盘重新加载。
4. **监控内存**：通过 `INFO memory` 命令监控内存使用情况，及时调整策略或扩容。

---

### **6. 示例场景**
#### **场景 1：电商缓存**
- **需求**：缓存商品信息，希望保留用户频繁浏览的商品。  
- **策略**：`allkeys-lfu`（全局 LFU，保留高频访问商品）。  
- **配置**：
  ```bash
  maxmemory 4gb
  maxmemory-policy allkeys-lfu
  ```

#### **场景 2：会话存储**
- **需求**：存储用户会话，会话有固定过期时间（如 30 分钟），希望尽快释放即将过期的会话。  
- **策略**：`volatile-ttl`（仅淘汰过期键，且优先删 TTL 短的）。  
- **配置**：
  ```bash
  maxmemory 2gb
  maxmemory-policy volatile-ttl
  ```

---

### **总结**
Redis 的内存淘汰策略是缓存设计的关键环节，选择策略时需综合考虑：
- **数据是否需要过期**（影响 `volatile-*` 或 `allkeys-*`）。  
- **访问模式**（随机、LRU、LFU）。  
- **业务容忍度**（是否允许写入失败）。  

**最佳实践**：  
- 生产环境建议使用 `allkeys-lru` 或 `allkeys-lfu`（缓存无过期时间时）。  
- 若数据有过期时间，优先选择 `volatile-lru` 或 `volatile-lfu`。  
- 监控内存使用和淘汰情况，动态调整策略。
