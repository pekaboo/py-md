# MySQL 索引的最左前缀匹配原则是什么？

**难度**：简单

**创建时间**：2025-10-04 08:34:19

## 答案
**MySQL索引的最左前缀匹配原则是指在使用联合索引（复合索引）时，查询条件必须从索引的最左列开始，并连续匹配后续列，才能有效利用索引。**以下是关于该原则的详细解释：

### **一、最左前缀匹配原则的定义**

* **核心要求**：查询条件必须包含索引的最左列，然后依次向右匹配后续列。
* **示例**：对于联合索引`(A, B, C)`，以下查询可以利用索引：

	* `WHERE A = ?`
	* `WHERE A = ? AND B = ?`
	* `WHERE A = ? AND B = ? AND C = ?`

* **无效查询**：以下查询无法利用索引（或仅部分利用）：

	* `WHERE B = ?`（跳过最左列`A`）
	* `WHERE A = ? AND C = ?`（跳过中间列`B`）

### **二、最左前缀匹配原则的原理**

* **B+树索引结构**：联合索引在B+树中按列定义的顺序构建。例如，索引`(A, B, C)`的存储结构为：

	* 首先按`A`列排序。
	* 在`A`相同的情况下，按`B`列排序。
	* 在`A`和`B`都相同的情况下，按`C`列排序。

* **查询效率考量**：如果不从最左列开始查询，就无法利用索引的有序性。例如，跳过`A`直接查`B`，相当于在无序数据中查找，导致索引失效，MySQL优化器会选择全表扫描。

### **三、最左前缀匹配原则的应用场景**

1. **多列联合索引**：当表中存在多个列的联合索引时，查询优化器依赖最左前缀匹配原则来决定是否使用该索引。
2. **范围查询**：在涉及范围查询（如`>`、`<`、`BETWEEN`、`LIKE 'xx%'`）的情况下，最左前缀匹配原则依然适用。但范围查询会限制索引的进一步使用，导致后续列无法被优化器利用。
3. **排序与分组**：在使用`ORDER BY`或`GROUP BY`时，满足最左前缀匹配原则的索引可以避免额外的排序操作，进一步提升查询效率。
4. **复合查询条件**：在复杂查询中，多个条件可能会涉及不同的列。理解最左前缀匹配原则有助于设计合理的索引，以覆盖最常见的查询路径。

### **四、最左前缀匹配原则的示例分析**

* **示例1**：联合索引`(first_name, last_name)`

	* 有效查询：

		* `WHERE first_name = 'John'`
		* `WHERE first_name = 'John' AND last_name = 'Doe'`

	* 无效查询：

		* `WHERE last_name = 'Doe'`

* **示例2**：联合索引`(department_id, salary)`

	* 有效查询：

		* `WHERE department_id = 5`
		* `WHERE department_id = 5 AND salary > 50000`

	* 无效查询：

		* `WHERE salary > 50000`

* **示例3**：涉及`LIKE`操作符的查询

	* 对于联合索引`(category, sub_category)`，以下查询可以利用索引：

		* `WHERE category = 'Electronics' AND sub_category LIKE 'Smart%'`（前缀匹配）

	* 以下查询无法利用索引：

		* `WHERE category = 'Electronics' AND sub_category LIKE '%Smart%'`（通配符开头）

### **五、最左前缀匹配原则的优化建议**

1. **索引列顺序设计**：

	* **基数原则**：将高基数列（唯一值多的列）放在前面。例如，用户ID比性别更适合作为首列。
	* **查询频率优先**：将最频繁查询的列放在前面，即使它的基数不是最高的。例如，状态字段可能查询频率极高。
	* **范围查询位置**：将范围查询的列尽量放在后面，避免其后的列无法使用索引。

2. **覆盖索引优化**：将`SELECT`中需要的列包含在索引中，避免回表操作，提升性能。例如，`SELECT A, B FROM table WHERE A = 1`，索引`(A, B)`比`(A)`更好。

3. **排序和分组优化**：`ORDER BY`/`GROUP BY`的列应尽量包含在索引中，并保持与索引顺序一致，可以避免`filesort`操作。
