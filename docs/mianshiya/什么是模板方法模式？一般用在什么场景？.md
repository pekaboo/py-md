# 什么是模板方法模式？一般用在什么场景？

**难度**：简单

**创建时间**：2025-10-06 05:56:11

## 答案
**模板方法模式（Template Method Pattern）** 是一种行为设计模式，它通过定义一个算法的骨架（即固定流程），将某些步骤的具体实现延迟到子类中完成，从而允许子类在不改变算法结构的情况下重新定义特定步骤。

---

### **核心思想**
1. **父类定义算法骨架**：在抽象父类中定义一个`模板方法`（通常是`final`修饰），该方法包含算法的固定步骤和顺序。
2. **子类实现可变步骤**：将算法中可变的步骤抽象为方法（或钩子方法），由子类具体实现。
3. **“好莱坞原则”**：父类控制流程，子类仅实现特定步骤（“别调用我们，我们会调用你”）。

---

### **模式结构**
1. **抽象父类（AbstractClass）**：
   - 定义`模板方法`（如`algorithm()`），包含算法骨架。
   - 声明抽象方法（如`step1()`、`step2()`），由子类实现。
   - 可选提供钩子方法（如`isStepNeeded()`），允许子类修改默认行为。

2. **具体子类（ConcreteClass）**：
   - 实现父类定义的抽象方法。
   - 可选重写钩子方法以调整流程。

---

### **代码示例（Java）**
#### **场景：数据导出（固定流程：初始化→处理数据→生成文件）**
```java
// 抽象父类：定义算法骨架
public abstract class DataExporter {
    // 模板方法（final防止子类修改流程）
    public final void export() {
        initialize();       // 固定步骤1：初始化
        processData();      // 固定步骤2：处理数据（子类实现）
        generateFile();     // 固定步骤3：生成文件（子类实现）
        if (needLog()) {    // 钩子方法：可选步骤
            log();
        }
    }

    // 固定步骤的具体实现（可被子类调用）
    protected void initialize() {
        System.out.println("初始化导出环境...");
    }

    // 抽象方法：子类必须实现
    protected abstract void processData();
    protected abstract void generateFile();

    // 钩子方法：默认返回true，子类可重写
    protected boolean needLog() {
        return true;
    }

    // 钩子方法的具体实现（可选）
    protected void log() {
        System.out.println("导出完成，生成日志...");
    }
}

// 具体子类：CSV导出
public class CsvExporter extends DataExporter {
    @Override
    protected void processData() {
        System.out.println("处理数据为CSV格式...");
    }

    @Override
    protected void generateFile() {
        System.out.println("生成CSV文件...");
    }

    @Override
    protected boolean needLog() {
        return false; // 覆盖钩子方法，不生成日志
    }
}

// 具体子类：JSON导出
public class JsonExporter extends DataExporter {
    @Override
    protected void processData() {
        System.out.println("处理数据为JSON格式...");
    }

    @Override
    protected void generateFile() {
        System.out.println("生成JSON文件...");
    }
}

// 使用
public class Client {
    public static void main(String[] args) {
        DataExporter csvExporter = new CsvExporter();
        csvExporter.export(); // 输出：初始化→处理CSV→生成CSV→（不生成日志）

        DataExporter jsonExporter = new JsonExporter();
        jsonExporter.export(); // 输出：初始化→处理JSON→生成JSON→生成日志
    }
}
```

---

### **典型应用场景**
1. **算法框架**：
   - 当多个类需要执行相似步骤但部分步骤不同时（如排序算法中的比较逻辑）。
   - 示例：`Arrays.sort()`内部可能使用模板方法，允许子类自定义比较器。

2. **流程控制**：
   - 需要严格控制执行顺序的场景（如编译过程：词法分析→语法分析→代码生成）。
   - 示例：Spring的`AbstractController`定义请求处理流程，子类实现具体逻辑。

3. **代码复用**：
   - 避免重复代码，将公共流程封装在父类中。
   - 示例：测试框架中，`setUp()`和`tearDown()`作为固定步骤，子类实现测试用例。

4. **钩子方法扩展**：
   - 通过钩子方法允许子类选择性覆盖默认行为。
   - 示例：游戏AI中，父类定义攻击流程，子类通过钩子决定是否闪避。

---

### **优点**
1. **代码复用**：公共逻辑封装在父类中，减少重复代码。
2. **扩展性**：子类仅需实现特定步骤，无需修改整体流程。
3. **一致性**：强制子类遵循父类定义的算法结构。

---

### **缺点**
1. **类数量增加**：每个可变步骤可能需要一个抽象方法，导致父类臃肿。
2. **灵活性限制**：子类只能通过重写方法扩展，无法修改算法骨架。
3. **抽象难度**：需要准确识别算法中的不变与可变部分。

---

### **与其他模式的对比**
- **策略模式**：动态切换整个算法，而模板方法固定算法结构，仅替换部分步骤。
- **工厂模式**：关注对象创建，模板方法关注算法流程。

---

### **实际应用案例**
1. **Java I/O中的`InputStream`**：
   - `read()`是模板方法，子类（如`FileInputStream`）实现具体读取逻辑。
2. **Spring的`JdbcTemplate`**：
   - 封装数据库操作流程（连接→执行→关闭），子类实现SQL和结果处理。
3. **JUnit测试框架**：
   - `TestCase`定义`run()`模板方法，子类实现`setUp()`和`testMethod()`。

---

### **总结**
**模板方法模式适用于**：  
- 算法流程固定，但部分步骤需要灵活定制的场景。  
- 需要严格控制执行顺序且避免代码重复的情况。  

通过将不变行为封装在父类中，可变行为交给子类实现，模板方法模式在框架设计和流程控制中发挥了重要作用。
