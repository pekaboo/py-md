# 让你设计一个短链系统，怎么设计？

**难度**：困难

**创建时间**：2025-10-06 15:43:51

## 答案
设计一个高可用、高性能的短链系统需要综合考虑**短链生成**、**快速跳转**、**防攻击**和**数据分析**等核心需求。以下是分步骤的详细设计方案，涵盖技术选型、核心模块和优化策略：

---

### **一、核心设计目标**
1. **短链唯一性**：确保不同长链生成不同短链
2. **高并发支持**：应对每秒数万级跳转请求
3. **低延迟**：跳转响应时间 < 50ms
4. **防刷机制**：阻止恶意爬取和滥用
5. **可扩展性**：支持十亿级短链存储

---

### **二、系统架构分层**
```
客户端 → CDN → 负载均衡 → 短链服务 → 缓存层 → 存储层 → 监控系统
```

#### 1. 前端优化（可选）
- **预解析JS**：在网页中预加载短链解析逻辑
- **本地缓存**：浏览器缓存已访问的短链映射
- **HTTP DNS**：避免DNS劫持导致解析失败

#### 2. 接入层（API Gateway）
- **限流策略**：
  - 用户级限流（如每个IP每秒100次请求）
  - 短链级限流（如热门短链单独限流）
  ```java
  // Guava RateLimiter示例
  RateLimiter limiter = RateLimiter.create(1000); // 每秒1000个请求
  if (!limiter.tryAcquire()) {
      throw new RuntimeException("请求过于频繁");
  }
  ```
- **防刷机制**：
  - 请求头校验（Referer/User-Agent）
  - 行为分析（如短时间内大量不同短链访问）

#### 3. 短链生成服务
##### **方案一：自增ID编码（推荐）**
1. **数据库自增ID**：
   ```sql
   CREATE TABLE short_url (
     id BIGINT AUTO_INCREMENT PRIMARY KEY,
     original_url VARCHAR(2048) NOT NULL,
     create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );
   ```
2. **ID转62进制**：
   ```java
   // 62进制字符集（0-9,a-z,A-Z）
   private static final char[] CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
   
   public static String encode(long num) {
       StringBuilder sb = new StringBuilder();
       while (num > 0) {
           sb.append(CHARS[(int)(num % 62)]);
           num /= 62;
       }
       return sb.reverse().toString();
   }
   ```
   - 示例：`123456789` → `1Y2`

##### **方案二：哈希算法（适合分布式）**
1. **MurmurHash3**（低碰撞率）：
   ```java
   import net.openhft.hashing.LongHashFunction;
   
   public static String hashUrl(String url) {
       long hash = LongHashFunction.murmur3_128().hashChars(url).asLong();
       return encode(hash & 0x7FFFFFFFFFFFFFFFL); // 取正数部分
   }
   ```
2. **截取哈希值**：取前6-8位作为短码

##### **方案三：发号器（分布式ID）**
- 使用**雪花算法(Snowflake)**生成唯一ID：
  ```java
  // 64位ID结构：时间戳(41)+工作机ID(10)+序列号(12)
  public class SnowflakeIdGenerator {
      private final long twepoch = 1288834974657L;
      private final long workerIdBits = 5L;
      // ... 实现省略
  }
  ```

#### 4. 短链解析服务
##### **缓存层（Redis集群）**
- **两级缓存**：
  1. **本地缓存**（Caffeine/Guava）：
     ```java
     LoadingCache<String, String> cache = Caffeine.newBuilder()
         .maximumSize(10_000)
         .expireAfterWrite(10, TimeUnit.MINUTES)
         .build(key -> redis.get("short_url:" + key));
     ```
  2. **Redis缓存**：
     ```bash
     # 存储格式：短码 → 长链
     SET short:abc123 "https://example.com/long/url" EX 3600
     ```
- **缓存穿透防护**：
  - 对不存在的短码返回空值缓存（如缓存1分钟）
  - 布隆过滤器预过滤（RedisBloom模块）

##### **存储层（分库分表）**
- **MySQL分片策略**：
  ```sql
  -- 按短码哈希值分10个库
  CREATE TABLE short_url_0 (
    short_code VARCHAR(10) PRIMARY KEY,
    original_url VARCHAR(2048) NOT NULL,
    click_count INT DEFAULT 0,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  -- 类似创建short_url_1到short_url_9
  ```
- **查询路由**：
  ```java
  public String getOriginalUrl(String shortCode) {
      int shard = Math.abs(shortCode.hashCode()) % 10;
      // 查询对应分库
  }
  ```

#### 5. 跳转服务
- **301 vs 302重定向**：
  - **301永久重定向**：适合不常变更的长链（SEO友好）
  - **302临时重定向**：适合需要统计点击的场景
- **重定向优化**：
  ```nginx
  # Nginx配置示例
  location /abc123 {
      set $original_url "";
      access_by_lua '
          local res = ngx.location.capture("/api/resolve", {args = {code=ngx.var[1]}})
          if res.status == 200 then
              ngx.var.original_url = res.body
          else
              ngx.exit(404)
          end
      ';
      return 301 $original_url;
  }
  ```

#### 6. 数据分析服务
- **点击日志**：
  ```java
  // 使用异步日志减少延迟
  @Async
  public void logClick(String shortCode, String ip) {
      clickLogDao.insert(new ClickLog(shortCode, ip, System.currentTimeMillis()));
  }
  ```
- **实时统计**：
  ```sql
  -- 近1小时点击量
  SELECT short_code, COUNT(*) as cnt 
  FROM click_log 
  WHERE create_time > NOW() - INTERVAL 1 HOUR
  GROUP BY short_code;
  ```
- **数据仓库**：
  - 每日汇总到Hive/ClickHouse
  - 支持多维分析（地域、设备类型等）

---

### **三、关键优化点**
#### 1. 短码生成策略对比
| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **自增ID编码** | 短码最短（6-8位），无碰撞 | 需要中心化存储 | 内部系统优先 |
| **哈希算法** | 分布式可扩展 | 短码较长（8-10位） | 公开服务适用 |
| **发号器** | 完全分布式 | 短码长度固定 | 超大规模系统 |

#### 2. 高并发优化
- **连接池优化**：
  ```yaml
  # HikariCP配置示例
  spring:
    datasource:
      hikari:
        maximum-pool-size: 50
        connection-timeout: 3000
  ```
- **Redis管道(Pipeline)**：
  ```java
  // 批量查询短链
  List<Object> results = redis.pipelined(jedis -> {
      for (String code : shortCodes) {
          jedis.get("short:" + code);
      }
  });
  ```

#### 3. 防攻击策略
- **IP黑名单**：
  ```sql
  -- 拦截高频IP
  CREATE TABLE blacklist (
    ip VARCHAR(15) PRIMARY KEY,
    ban_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reason VARCHAR(100)
  );
  ```
- **请求签名**：
  ```java
  // 客户端生成签名
  String sign = HmacSHA256(secretKey, shortCode + timestamp);
  
  // 服务端验证
  if (!sign.equals(calculateSign(request))) {
      throw new SecurityException("签名无效");
  }
  ```

---

### **四、监控与告警**
1. **核心指标**：
   - 解析成功率（> 99.99%）
   - 平均响应时间（< 30ms）
   - 缓存命中率（> 95%）
2. **告警规则**：
   - 500错误率 > 0.1%
   - 数据库连接池耗尽
   - 短码碰撞事件

---

### **五、完整流程示例**
1. **生成短链**：
   - 用户提交长链 → 系统生成唯一ID → 编码为62进制短码 → 存入Redis和MySQL
2. **访问短链**：
   - 用户访问 `https://s.cn/abc123` → CDN缓存命中则直接返回 → 未命中则查询Redis → 未命中则查MySQL → 301重定向
3. **数据分析**：
   - 异步记录点击日志 → 每分钟汇总到Kafka → 消费者处理后存入ClickHouse

---

### **六、压测数据参考**
| 优化措施 | QPS提升 | 响应时间降低 |
|----------|----------|--------------|
| Redis缓存 | 100倍    | 90%          |
| 连接池优化 | 3倍      | 50%          |
| 异步日志 | 2倍      | 30%          |
| 分库分表 | 5倍      | 40%          |

---

### **七、避坑指南**
1. **不要用MD5截取**：容易导致碰撞（如不同长链生成相同短码）
2. **避免短码可预测**：如顺序数字短码易被爬取
3. **慎用内存缓存**：十亿级短码会耗尽内存
4. **监控短码长度**：防止哈希冲突导致短码变长
5. **准备降级方案**：如Redis故障时直接查MySQL

通过这种设计，系统可以轻松支持每秒数万次的短链解析请求，同时保证短码的唯一性和系统的稳定性。实际实施时建议先在小流量环境验证短码生成算法，再逐步放大流量。
