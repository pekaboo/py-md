# 什么是策略模式？一般用在什么场景？

**难度**：简单

**创建时间**：2025-10-05 12:11:59

## 答案
**策略模式（Strategy Pattern）** 是一种行为设计模式，它通过定义一系列算法（策略），并将它们封装成独立的对象，使得算法可以独立于使用它的客户端变化。策略模式的核心思想是将**算法的变体（策略）与使用算法的上下文（环境）解耦**，从而支持算法的动态切换和扩展。

---

### **一、策略模式的结构**
策略模式通常包含以下角色：
1. **上下文（Context）**：  
   - 维护一个对策略对象的引用（通过组合而非继承）。
   - 定义接口，供客户端调用策略。
2. **策略接口（Strategy Interface）**：  
   - 定义所有具体策略的通用接口。
3. **具体策略（Concrete Strategies）**：  
   - 实现策略接口，封装具体的算法逻辑。

#### **类图示例**
```mermaid
classDiagram
    class Context {
        -strategy: Strategy
        +setStrategy(Strategy)
        +executeStrategy()
    }
    interface Strategy {
        <<interface>>
        +execute()
    }
    class ConcreteStrategyA {
        +execute()
    }
    class ConcreteStrategyB {
        +execute()
    }
    Context o--> Strategy
    Strategy <|-- ConcreteStrategyA
    Strategy <|-- ConcreteStrategyB
```

---

### **二、策略模式的核心优势**
1. **解耦算法与使用环境**  
   - 算法的实现细节被封装在策略类中，上下文无需关心具体逻辑，只需调用策略接口。
2. **支持动态切换算法**  
   - 运行时可通过修改上下文中的策略对象来切换算法（如根据用户选择切换排序方式）。
3. **易于扩展新策略**  
   - 遵循**开闭原则**，新增策略无需修改现有代码（只需实现策略接口）。
4. **避免条件分支**  
   - 替代复杂的`if-else`或`switch-case`语句，使代码更清晰。

---

### **三、典型应用场景**
#### 1. **算法动态切换**
   - **场景**：需要根据运行时条件选择不同算法。  
   - **案例**：  
     - 压缩工具支持多种压缩算法（ZIP、RAR、7Z），用户选择后动态切换。  
     - 导航应用支持多种路径规划算法（最短时间、最少费用、避开高速）。

#### 2. **消除条件分支**
   - **场景**：代码中存在大量`if-else`或`switch-case`判断算法类型。  
   - **案例**：  
     - 支付系统支持多种支付方式（信用卡、支付宝、微信），通过策略模式避免条件判断。  
     ```java
     // 传统方式（条件分支）
     public void pay(String paymentType) {
         if ("credit".equals(paymentType)) {
             // 信用卡支付逻辑
         } else if ("alipay".equals(paymentType)) {
             // 支付宝支付逻辑
         }
     }

     // 策略模式
     public interface PaymentStrategy {
         void pay(double amount);
     }
     public class CreditCardPayment implements PaymentStrategy {
         @Override public void pay(double amount) { /* 信用卡逻辑 */ }
     }
     public class AlipayPayment implements PaymentStrategy {
         @Override public void pay(double amount) { /* 支付宝逻辑 */ }
     }
     public class PaymentContext {
         private PaymentStrategy strategy;
         public void setStrategy(PaymentStrategy strategy) { this.strategy = strategy; }
         public void executePayment(double amount) { strategy.pay(amount); }
     }
     ```

#### 3. **支持多版本算法**
   - **场景**：同一功能有多种实现（如加密算法、排序算法）。  
   - **案例**：  
     - 排序服务支持冒泡排序、快速排序、归并排序，通过策略模式选择算法。  
     - 加密工具支持AES、DES、RSA加密，根据安全级别动态切换。

#### 4. **游戏中的AI行为**
   - **场景**：游戏角色需要根据状态选择不同行为策略。  
   - **案例**：  
     - 敌人AI在不同难度下采用不同攻击策略（简单难度：随机移动；困难难度：追踪玩家）。

#### 5. **日志记录策略**
   - **场景**：根据环境（开发、测试、生产）选择不同的日志输出方式。  
   - **案例**：  
     - 开发环境输出详细日志到控制台，生产环境输出关键日志到文件。

---

### **四、策略模式与其他模式的对比**
| 模式          | 核心思想                          | 适用场景                          |
|---------------|-----------------------------------|-----------------------------------|
| **策略模式**  | 封装可互换的算法                  | 算法动态切换、消除条件分支        |
| **模板方法**  | 定义算法骨架，子类实现步骤        | 算法框架固定，部分步骤可变        |
| **状态模式**  | 封装对象状态变化，自动切换行为    | 对象状态改变导致行为变化（如订单状态） |
| **工厂模式**  | 封装对象创建逻辑                  | 根据条件创建不同实例              |

---

### **五、策略模式的实现方式**
#### 1. **通过构造函数注入策略**
   ```java
   public class Context {
       private final Strategy strategy;
       public Context(Strategy strategy) {
           this.strategy = strategy;
       }
       public void execute() {
           strategy.execute();
       }
   }
   ```

#### 2. **通过Setter方法动态切换策略**
   ```java
   public class Context {
       private Strategy strategy;
       public void setStrategy(Strategy strategy) {
           this.strategy = strategy;
       }
       public void execute() {
           strategy.execute();
       }
   }
   ```

#### 3. **Java 8+ 的函数式接口**
   - 使用`Function`或自定义函数式接口简化策略实现：
   ```java
   public class PaymentContext {
       private Function<Double, Void> paymentStrategy;
       public void setStrategy(Function<Double, Void> strategy) {
           this.paymentStrategy = strategy;
       }
       public void pay(double amount) {
           paymentStrategy.apply(amount);
       }
   }
   // 使用
   PaymentContext context = new PaymentContext();
   context.setStrategy(amount -> { 
       System.out.println("Paying " + amount + " via Alipay"); 
       return null; 
   });
   context.pay(100.0);
   ```

---

### **六、策略模式的局限性**
1. **客户端需了解所有策略**：  
   - 客户端必须知道所有具体策略类，并决定使用哪一个（可通过工厂模式简化）。
2. **策略对象增加开销**：  
   - 每个具体策略都是一个类，可能增加系统复杂度（但通常收益大于成本）。
3. **无法共享状态**：  
   - 策略对象通常是无状态的，若需共享状态需额外处理（如通过上下文传递）。

---

### **七、总结**
**策略模式适用于以下场景**：  
- 一个系统需要动态地在几种算法中选择一种。  
- 避免使用复杂的条件语句来选择算法。  
- 需要封装算法的实现细节，便于维护和扩展。  

**典型案例**：  
- 支付系统（多种支付方式）。  
- 排序/压缩/加密工具（多种算法）。  
- 游戏AI（不同行为策略）。  

通过策略模式，可以轻松实现算法的“热插拔”，提升代码的灵活性和可测试性。
