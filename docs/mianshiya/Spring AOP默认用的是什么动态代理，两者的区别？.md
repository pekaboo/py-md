# Spring AOP默认用的是什么动态代理，两者的区别？

**难度**：中等

**创建时间**：2025-10-06 15:39:43

## 答案
Spring AOP 默认使用 **JDK 动态代理**，当目标对象未实现接口时，会退而使用 **CGLIB 动态代理**。两者在实现机制、性能、适用场景等方面存在显著差异，具体如下：

### **一、实现机制对比**
| **维度**         | **JDK 动态代理**                                                                 | **CGLIB 动态代理**                                                                 |
|------------------|---------------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| **核心原理**     | 基于 Java 反射机制，通过 `java.lang.reflect.Proxy` 类和 `InvocationHandler` 接口实现。 | 基于字节码操作（ASM 库），通过继承目标类并重写方法实现代理。                      |
| **代理对象类型** | 代理对象实现目标接口，类型为接口类型（如 `Pojo`）。                              | 代理对象为目标类的子类，类型为具体类（如 `BookDaoImpl$$EnhancerBySpringCGLIB$$`）。 |
| **方法拦截**     | 通过 `InvocationHandler.invoke()` 方法反射调用目标方法，并插入切面逻辑。          | 通过重写目标类方法，在方法体内直接插入切面逻辑。                                  |

### **二、性能对比**
1. **代理创建速度**  
   - JDK 动态代理更快：仅需生成实现接口的代理类字节码。  
   - CGLIB 动态代理较慢：需生成继承目标类的子类字节码，过程更复杂。  

2. **方法调用速度**  
   - JDK 动态代理较慢：依赖反射调用目标方法，存在性能开销。  
   - CGLIB 动态代理更快：直接调用重写后的方法，减少反射开销。  

**典型场景**：  
- 高频短方法调用（如 RPC 框架）：CGLIB 性能更优。  
- 低频长方法调用（如初始化逻辑）：JDK 代理差异可忽略。

### **三、适用场景对比**
| **场景**                     | **JDK 动态代理**                          | **CGLIB 动态代理**                          |
|------------------------------|------------------------------------------|------------------------------------------|
| **目标对象类型**             | 必须实现至少一个接口。                    | 无需实现接口，但不可为 `final` 类或方法。 |
| **典型用例**                 | Spring Bean 方法增强、RPC 框架（如 gRPC）。 | 无接口的 Spring Bean、AOP 切面织入。      |
| **强制使用配置**             | 默认优先使用，无需额外配置。              | 需通过 `<aop:config proxy-target-class="true"/>` 或 `@EnableAspectJAutoProxy(proxyTargetClass=true)` 强制启用。 |

### **四、关键限制对比**
| **限制**                     | **JDK 动态代理**                          | **CGLIB 动态代理**                          |
|------------------------------|------------------------------------------|------------------------------------------|
| **接口要求**                 | 必须实现接口，否则无法代理。              | 无需接口，但目标类/方法不可为 `final`。   |
| **方法代理范围**             | 仅能代理接口中定义的方法。                | 可代理目标类中所有可重写的方法（非 `final`）。 |
| **自我调用问题**             | 代理仅拦截外部调用，内部调用不触发切面。  | 同 JDK 代理，需通过 `AopContext.currentProxy()` 获取代理对象解决。 |

### **五、选择建议**
1. **默认情况**：  
   - 优先使用 JDK 动态代理（符合面向接口编程思想，代码更简洁）。  
   - 仅在目标对象无接口时，自动降级使用 CGLIB。

2. **强制使用 CGLIB 的场景**：  
   - 目标对象无接口，且需代理非 `public` 方法（JDK 代理仅支持 `public` 方法）。  
   - 性能敏感场景（如高频方法调用），且目标类非 `final`。

3. **避免使用的场景**：  
   - 目标类为 `final` 或包含 `final` 方法（CGLIB 无法继承/重写）。  
   - 需代理接口中未定义的方法（JDK 代理无法覆盖）。
