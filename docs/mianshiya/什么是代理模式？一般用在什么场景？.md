# 什么是代理模式？一般用在什么场景？

**难度**：中等

**创建时间**：2025-10-06 05:56:40

## 答案
代理模式（Proxy Pattern）是一种**结构型设计模式**，它通过为其他对象提供一个**代理对象**（或占位符），间接控制对原始对象的访问。代理模式的核心思想是**在不改变原始对象的前提下，扩展或控制其行为**，常用于实现延迟加载、访问控制、日志记录等场景。

---

### **核心概念**
1. **主题接口（Subject）**：
   - 定义代理对象和真实对象共同的接口，客户端通过该接口与代理交互。

2. **真实对象（Real Subject）**：
   - 被代理的对象，实际执行业务逻辑。

3. **代理对象（Proxy）**：
   - 实现与真实对象相同的接口，在调用真实对象方法前后添加额外逻辑（如权限检查、日志记录、延迟初始化等）。

---

### **代理模式的类型**
根据用途不同，代理模式可分为以下几种：

#### 1. **远程代理（Remote Proxy）**
   - **作用**：为远程对象提供本地代表，隐藏网络通信细节。
   - **场景**：RPC调用、Web Service（如通过代理访问远程服务）。
   - **示例**：Java RMI中的存根（Stub）和骨架（Skeleton）。

#### 2. **虚拟代理（Virtual Proxy）**
   - **作用**：延迟创建高开销对象，直到真正需要时才初始化。
   - **场景**：
     - 加载大图像或复杂对象时（先显示占位图，再加载实际数据）。
     - 数据库连接池（按需创建连接）。
   - **示例**：浏览器中图片的懒加载。

#### 3. **保护代理（Protection Proxy）**
   - **作用**：控制对真实对象的访问权限（如基于角色或权限）。
   - **场景**：
     - 用户权限管理（普通用户无法访问管理员功能）。
     - 数据加密/解密（代理在调用前后处理敏感数据）。
   - **示例**：Spring Security中的权限拦截。

#### 4. **智能引用代理（Smart Reference Proxy）**
   - **作用**：在对象被访问时执行额外操作（如计数、锁、缓存）。
   - **场景**：
     - 统计对象访问次数。
     - 实现写时复制（Copy-on-Write）。
   - **示例**：Java中的`WeakReference`或`SoftReference`。

#### 5. **缓存代理（Cache Proxy）**
   - **作用**：缓存结果，避免重复计算或远程调用。
   - **场景**：
     - 数据库查询结果缓存。
     - 计算密集型任务的中间结果缓存。
   - **示例**：Spring Cache中的`@Cacheable`注解。

---

### **代码示例（Java）**
#### 场景：虚拟代理（延迟加载图片）
```java
// 1. 定义主题接口
interface Image {
    void display();
}

// 2. 真实对象（高开销操作）
class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk(); // 模拟耗时操作
    }

    private void loadFromDisk() {
        System.out.println("加载图片: " + filename);
    }

    @Override
    public void display() {
        System.out.println("显示图片: " + filename);
    }
}

// 3. 代理对象（延迟加载）
class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // 首次调用时初始化
        }
        realImage.display();
    }
}

// 4. 客户端使用
public class Client {
    public static void main(String[] args) {
        Image image = new ProxyImage("test.jpg"); // 代理对象
        System.out.println("第一次调用display:");
        image.display(); // 此时才会加载真实图片

        System.out.println("\n第二次调用display:");
        image.display(); // 直接使用缓存的RealImage
    }
}
```
**输出**：
```
第一次调用display:
加载图片: test.jpg
显示图片: test.jpg

第二次调用display:
显示图片: test.jpg
```

---

### **适用场景**
1. **延迟初始化（Lazy Initialization）**：
   - 对象创建开销大，且可能不被使用（如打开大文件、建立数据库连接）。

2. **访问控制**：
   - 根据用户权限过滤对敏感资源的访问（如管理员才能删除数据）。

3. **远程调用**：
   - 隐藏网络通信细节，提供本地接口访问远程服务（如gRPC、REST API代理）。

4. **日志与审计**：
   - 记录方法调用信息（如参数、耗时），用于调试或合规性检查。

5. **缓存结果**：
   - 避免重复计算或远程调用（如查询数据库后缓存结果）。

6. **资源池管理**：
   - 控制对有限资源（如线程池、数据库连接）的访问。

7. **简化复杂对象**：
   - 为复杂对象提供简化接口（如Facade模式的轻量级实现）。

---

### **实际应用案例**
1. **Spring AOP**：
   - 通过代理实现声明式事务、日志记录（如`@Transactional`注解）。

2. **动态代理（JDK/CGLIB）**：
   - JDK动态代理基于接口，CGLIB代理基于继承，用于实现RPC、ORM框架（如MyBatis）。

3. **Nginx反向代理**：
   - 作为Web服务器的代理，实现负载均衡、SSL终止、缓存。

4. **CDN（内容分发网络）**：
   - 代理原始服务器，缓存静态资源并就近返回。

5. **数据库连接池**：
   - 代理数据库连接，管理连接的生命周期和并发访问。

6. **Android中的图片加载库（Glide/Picasso）**：
   - 使用虚拟代理延迟加载图片，避免内存溢出。

---

### **优缺点**
#### **优点**
- **解耦**：客户端无需直接依赖真实对象，降低耦合度。
- **扩展性**：可在不修改真实对象的情况下添加新功能（如日志、缓存）。
- **控制访问**：统一管理权限、资源或生命周期。

#### **缺点**
- **性能开销**：代理层可能增加调用链的复杂度。
- **实现复杂**：需正确处理代理与真实对象的交互逻辑。
- **过度设计**：简单场景下可能引入不必要的间接性。

---

### **与其他模式的对比**
- **装饰器模式**：代理模式侧重控制访问，装饰器模式侧重动态添加功能。
- **适配器模式**：代理模式接口相同，适配器模式接口不同。
- **外观模式**：代理模式控制单个对象访问，外观模式简化子系统接口。

---

### **总结**
代理模式通过引入中间层，实现了对真实对象的**间接控制**，适用于需要延迟加载、访问控制、日志记录或远程调用的场景。它在框架设计（如Spring、MyBatis）和分布式系统（如RPC、CDN）中广泛应用，能够显著提升系统的灵活性和可维护性。
