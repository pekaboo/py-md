# 为什么 Java 中 HashMap 的默认负载因子是 0.75？

**难度**：中等

**创建时间**：2025-10-06 06:00:37

## 答案
Java 中 `HashMap` 的默认负载因子（load factor）设置为 **0.75** 是一个经过权衡的折中方案，旨在平衡**空间利用率**和**操作效率**。以下是具体原因和背后的设计逻辑：

---

### **1. 负载因子的定义**
负载因子（`loadFactor`）是 `HashMap` 的一个关键参数，表示**哈希表在扩容前的填充程度**。计算公式为：
```
负载因子 = 元素数量 / 桶数量（table.length）
```
- 当元素数量超过 `负载因子 × 桶数量` 时，`HashMap` 会触发扩容（重新哈希）。
- 默认负载因子为 `0.75`，即当哈希表填充到 75% 时扩容。

---

### **2. 为什么选择 0.75？**
#### **(1) 空间与时间的权衡**
- **较低的负载因子（如 0.5）**：  
  - **优点**：减少哈希冲突，提高查询/插入效率（链表或树更短）。  
  - **缺点**：浪费更多内存（桶利用率低），扩容更频繁（增加 CPU 开销）。  

- **较高的负载因子（如 0.9）**：  
  - **优点**：节省内存（桶利用率高）。  
  - **缺点**：增加哈希冲突概率，导致链表变长或树化频繁，操作效率下降（尤其是查询）。  

- **0.75 的折中**：  
  - 在大多数场景下，既能保持较高的空间利用率（75% 填充率），又能将冲突概率控制在可接受范围（链表长度和树化频率适中）。

#### **(2) 数学与经验优化**
- **泊松分布分析**：  
  Java 官方文档提到，负载因子 `0.75` 是基于对哈希函数分布的统计假设（假设键的哈希值均匀分布）。此时，冲突概率和操作时间复杂度（如 `O(1)` 或 `O(log n)`）达到较好的平衡。  
  - 例如，当负载因子为 `0.75` 时，单个桶中链表长度的期望值较低，避免了频繁的树化（Java 8 后，链表长度 ≥ 8 时转为红黑树）。

- **经验值验证**：  
  通过大量测试和实际应用，`0.75` 被证明在大多数场景下能兼顾性能和内存开销。例如，在内存敏感型应用中，降低负载因子可能更优；而在高吞吐场景中，`0.75` 是安全的选择。

#### **(3) 避免频繁扩容**
- 扩容（rehashing）是一个高开销操作（需要重新计算所有键的哈希值并分配新桶）。  
- 如果负载因子过高（如 `0.9`），扩容会频繁触发，导致性能抖动；而 `0.75` 能将扩容频率控制在合理范围。

---

### **3. 对比其他语言/实现**
- **C++ STL 的 `unordered_map`**：默认负载因子通常为 `1.0`（更激进，但依赖高质量哈希函数）。  
- **Python 的 `dict`**：动态调整，无固定负载因子，但实现类似 `0.75` 的策略。  
- **Go 的 `map`**：通过动态扩容和随机化哈希种子优化冲突，无显式负载因子参数。  

Java 的 `0.75` 是一个相对保守且通用的选择，适合大多数业务场景。

---

### **4. 实际应用中的调整**
虽然 `0.75` 是默认值，但可以根据需求调整：
- **内存优先**：降低负载因子（如 `0.5`），减少冲突，但增加内存占用。  
- **性能优先**：保持 `0.75` 或略高（如 `0.8`），需测试实际冲突率。  
- **极端场景**：  
  - 如果键的哈希函数质量差（导致大量冲突），即使负载因子低，性能也会下降。  
  - 如果键分布均匀且内存充足，可适当提高负载因子。

---

### **5. 源码中的体现**
在 Java 的 `HashMap` 源码中，负载因子的作用体现在扩容条件：
```java
final float loadFactor;
// 扩容条件：元素数量 > 容量 × 负载因子
if (size++ > threshold) // threshold = capacity * loadFactor
    resize();
```

---

### **总结**
Java 选择 `0.75` 作为 `HashMap` 的默认负载因子，是因为：
1. **平衡空间与时间**：75% 的填充率在内存利用率和操作效率间取得较好折中。  
2. **数学与经验优化**：基于哈希分布假设和实际测试，冲突概率可控。  
3. **避免频繁扩容**：减少 rehashing 的开销，保持性能稳定。  

这一设计使得 `HashMap` 在大多数场景下既能高效运行，又不会过度消耗内存，体现了 Java 集合框架的“合理默认值”哲学。
