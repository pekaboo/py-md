# Java 中有哪些集合类？请简单介绍

**难度**：简单

**创建时间**：2025-10-02 13:15:22

## 答案
Java 中的集合类主要位于 `java.util` 包和 `java.util.concurrent` 包中，用于存储、操作和管理一组对象。根据数据结构和使用场景，集合类可分为 **List（列表）、Set（集合）、Queue（队列）** 和 **Map（映射）** 四大类。以下是详细分类和简介：

---

### **一、List（有序可重复集合）**
List 接口允许存储重复元素，且按插入顺序维护元素顺序，支持索引访问。

| **类名**               | **特点**                                                                 | **适用场景**                          |
|------------------------|--------------------------------------------------------------------------|---------------------------------------|
| **`ArrayList`**        | 基于动态数组，查询快（O(1)），插入/删除末尾快（O(1)），中间慢（O(n)）   | 频繁查询、随机访问                    |
| **`LinkedList`**      | 基于双向链表，插入/删除快（O(1)），查询慢（O(n)），支持队列操作          | 频繁插入/删除、实现栈/队列            |
| **`Vector`**           | 线程安全版 `ArrayList`（已过时，推荐用 `CopyOnWriteArrayList`）          | 低并发线程安全场景（不推荐）          |
| **`Stack`**            | 继承自 `Vector`，实现栈结构（后进先出，LIFO）                            | 栈操作（推荐用 `Deque` 替代）         |

**示例**：
```java
List<String> list = new ArrayList<>();
list.add("A");
list.get(0); // 随机访问
```

---

### **二、Set（无序不可重复集合）**
Set 接口不允许重复元素，且不保证顺序（部分实现有顺序）。

| **类名**               | **特点**                                                                 | **适用场景**                          |
|------------------------|--------------------------------------------------------------------------|---------------------------------------|
| **`HashSet`**          | 基于哈希表，查询/插入/删除快（O(1)），无序                               | 快速去重、无需顺序                    |
| **`LinkedHashSet`**   | 继承 `HashSet`，维护插入顺序                                             | 需要去重且保留顺序                    |
| **`TreeSet`**          | 基于红黑树，元素按自然顺序或自定义顺序排序，操作慢（O(log n)）           | 需要排序的去重场景                    |

**示例**：
```java
Set<String> set = new HashSet<>();
set.add("A");
set.contains("A"); // 快速查询
```

---

### **三、Queue（队列）**
Queue 接口用于存储按顺序处理的元素，支持先进先出（FIFO）或优先级队列。

| **类名**               | **特点**                                                                 | **适用场景**                          |
|------------------------|--------------------------------------------------------------------------|---------------------------------------|
| **`LinkedList`**      | 实现 `Deque` 接口，可作为双端队列（支持两端插入/删除）                   | 栈/队列操作                           |
| **`PriorityQueue`**   | 基于堆的优先级队列，元素按自然顺序或比较器排序                           | 优先级调度（如任务队列）              |
| **`ArrayDeque`**      | 基于数组的双端队列，比 `LinkedList` 更高效                               | 栈/队列操作（推荐替代 `Stack`）       |

**示例**：
```java
Queue<String> queue = new LinkedList<>();
queue.offer("A"); // 入队
queue.poll();    // 出队
```

---

### **四、Map（键值对映射）**
Map 接口存储键值对（Key-Value），键唯一，值可重复。

| **类名**               | **特点**                                                                 | **适用场景**                          |
|------------------------|--------------------------------------------------------------------------|---------------------------------------|
| **`HashMap`**          | 基于哈希表，查询/插入/删除快（O(1)），无序（JDK 1.8 后优化为红黑树）     | 通用键值对存储                        |
| **`LinkedHashMap`**   | 继承 `HashMap`，维护插入顺序或访问顺序                                   | 需要顺序的键值对（如 LRU 缓存）       |
| **`TreeMap`**          | 基于红黑树，键按自然顺序或自定义顺序排序，操作慢（O(log n)）             | 需要排序的键值对                      |
| **`Hashtable`**       | 线程安全版 `HashMap`（已过时，推荐用 `ConcurrentHashMap`）               | 低并发线程安全场景（不推荐）          |
| **`ConcurrentHashMap`**| 线程安全的 `HashMap`，分段锁或 CAS 优化，高并发性能好                    | 多线程环境下的键值对存储              |

**示例**：
```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.get("A"); // 快速查询
```

---

### **五、其他工具类**
1. **`Collections`**：提供集合操作的静态工具方法（如排序、同步包装）。
   ```java
   List<String> syncList = Collections.synchronizedList(new ArrayList<>());
   ```
2. **`Arrays`**：操作数组的工具类（如排序、转为列表）。
   ```java
   List<String> list = Arrays.asList("A", "B");
   ```

---

### **六、并发集合（`java.util.concurrent`）**
| **类名**               | **特点**                                                                 | **适用场景**                          |
|------------------------|--------------------------------------------------------------------------|---------------------------------------|
| **`ConcurrentHashMap`**| 线程安全的 `HashMap`，分段锁或 CAS 优化                                  | 多线程键值对存储                      |
| **`CopyOnWriteArrayList`**| 写时复制的线程安全 `ArrayList`，适合读多写少场景                        | 读多写少的列表                        |
| **`BlockingQueue`**   | 线程安全的队列（如 `ArrayBlockingQueue`、`LinkedBlockingQueue`）        | 生产者-消费者模型                     |

**示例**：
```java
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);
queue.put("A"); // 阻塞入队
```

---

### **总结：选择集合类的关键因素**
1. **是否需要顺序**：`List`（有序） vs `Set`/`Map`（无序或排序）。
2. **是否允许重复**：`List`（允许） vs `Set`（不允许）。
3. **操作频率**：查询多选 `HashMap`/`ArrayList`，插入/删除多选 `LinkedList`/`TreeSet`。
4. **线程安全**：单线程用普通集合，多线程用 `ConcurrentHashMap`/`CopyOnWriteArrayList`。
5. **排序需求**：`TreeSet`/`TreeMap`（自然排序或自定义排序）。

通过合理选择集合类，可以显著提升代码的效率和可维护性。
