# Java 的 synchronized 是怎么实现的？

**难度**：困难

**创建时间**：2025-10-06 15:42:49

## 答案
Java 中的 `synchronized` 关键字是实现线程同步的核心机制，它通过**内置锁（Intrinsic Lock）**保证代码块的**原子性、可见性和有序性**。其底层实现依赖于 JVM 和操作系统的协同，主要涉及**对象头、Monitor 记录器、锁升级机制**等。以下是详细实现原理：

---

### **一、synchronized 的底层实现**
#### **1. 基于对象头（Object Header）的锁标识**
Java 对象在内存中分为三部分：
- **对象头（Mark Word）**：存储对象的运行时数据（如哈希码、GC 分代年龄、锁状态）。
- **类指针（Class Pointer）**：指向对象的类元数据。
- **实例数据**：对象的字段值。

**Mark Word 的结构（32位系统示例）**：
```
|-----------------------------------------------------------------------|
| 锁状态   | 25bit        | 4bit    | 1bit（是否偏向锁） | 2bit（锁标志） |
|-----------------------------------------------------------------------|
| 无锁     | 对象哈希码   | 分代年龄 | 0                 | 01            |
| 偏向锁   | 线程ID       | epoch   | 1                 | 01            |
| 轻量级锁 | 指向栈中锁记录 |         |                   | 00            |
| 重量级锁 | 指向Monitor   |         |                   | 10            |
| GC标记   |              |         |                   | 11            |
|-----------------------------------------------------------------------|
```
- **锁标志位**（后2位）区分锁状态：`01`（无锁/偏向锁）、`00`（轻量级锁）、`10`（重量级锁）、`11`（GC标记）。

#### **2. Monitor 记录器（重量级锁）**
当锁升级为**重量级锁**时，JVM 会依赖操作系统的**互斥量（Mutex）**实现同步，此时锁记录在对象的**Monitor**中：
- **Monitor 结构**：
  - `_owner`：持有锁的线程。
  - `_EntryList`：等待获取锁的线程队列（阻塞状态）。
  - `_WaitSet`：调用 `wait()` 后释放锁的线程队列。
- **流程**：
  1. 线程尝试获取锁时，若锁已被占用，则进入 `_EntryList` 阻塞。
  2. 锁释放后，`_EntryList` 中的线程通过竞争（操作系统调度）获取锁。

---

### **二、锁升级过程**
JVM 会根据竞争情况动态调整锁的形态，以优化性能：

#### **1. 无锁 → 偏向锁（Biased Locking）**
- **适用场景**：锁仅被同一个线程重复获取（无竞争）。
- **实现**：
  - 在对象头中记录**线程ID**，后续同一线程进入同步块时无需同步操作（通过CAS修改Mark Word）。
  - 撤销偏向锁需等待全局安全点（Safe Point），性能开销较大。

#### **2. 偏向锁 → 轻量级锁（自旋锁）**
- **触发条件**：有其他线程尝试竞争偏向锁。
- **实现**：
  - 偏向锁撤销，锁标志位改为 `00`。
  - 线程在**用户态**通过**自旋（循环CAS）**尝试获取锁，避免操作系统线程调度。
  - 自旋默认次数为10次（可通过 `-XX:PreBlockSpin` 调整）。

#### **3. 轻量级锁 → 重量级锁**
- **触发条件**：自旋次数超过阈值或竞争线程数超过CPU核心数的一半。
- **实现**：
  - 锁标志位改为 `10`，未获取锁的线程进入 `_EntryList` 阻塞。
  - 依赖操作系统互斥量，涉及用户态到内核态的切换，性能较低。

---

### **三、synchronized 的代码示例与字节码分析**
#### **1. 同步代码块**
```java
public void syncMethod() {
    synchronized (this) {
        System.out.println("Synchronized block");
    }
}
```
**字节码**：
```
MONITORENTER  // 进入同步块，获取对象的Monitor
GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
LDC "Synchronized block"
INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
MONITOREXIT   // 退出同步块，释放Monitor
```

#### **2. 同步方法**
```java
public synchronized void syncMethod() {
    System.out.println("Synchronized method");
}
```
**字节码**：
- 方法表（Method Table）中会标记 `ACC_SYNCHRONIZED` 标志，JVM 在调用方法时自动获取对象的 Monitor。

---

### **四、synchronized 的特性**
1. **可重入性**  
   - 同一线程可重复获取锁（计数器递增），避免死锁。
2. **可见性保证**  
   - 锁释放时会强制将工作内存中的变量刷新到主内存（类似 `volatile` 的语义）。
3. **不可中断性**  
   - 线程在阻塞态时无法被中断（与 `Lock` 不同）。

---

### **五、性能优化建议**
1. **缩小同步范围**：避免在同步块中执行耗时操作（如I/O）。
2. **减少锁竞争**：
   - 使用**锁分离**（如读写锁 `ReentrantReadWriteLock`）。
   - 使用**并发容器**（如 `ConcurrentHashMap`）。
3. **避免锁升级**：高竞争场景下直接使用 `ReentrantLock` 或 `StampedLock`。

---

### **六、与 ReentrantLock 的对比**
| **特性**               | **synchronized**          | **ReentrantLock**               |
|------------------------|---------------------------|---------------------------------|
| **实现方式**           | JVM 内置                  | JDK API（基于 AQS）              |
| **灵活性**             | 固定                      | 可中断、可超时、公平锁/非公平锁 |
| **性能**               | 优化后接近                | 更高（无锁升级开销）            |
| **适用场景**           | 简单同步                  | 复杂控制（如条件变量 `Condition`） |

---

### **总结**
- `synchronized` 的底层通过**对象头锁标识 + Monitor 记录器 + 锁升级机制**实现线程同步。
- JVM 会根据竞争情况从**偏向锁 → 轻量级锁 → 重量级锁**动态升级。
- 现代 JDK 中通过**锁消除、锁粗化、偏向锁、自旋锁**等优化，使得 `synchronized` 的性能接近 `ReentrantLock`。
- 在简单同步场景下优先使用 `synchronized`，复杂场景（如可中断锁）选择 `ReentrantLock`。
