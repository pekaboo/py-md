<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{ metadata.title or site.title or '文档' }}</title>
  {% if metadata.description or site.description %}
  <meta name="description" content="{{ metadata.description or site.description }}" />
  {% endif %}
  {{ style_block | safe }}
  {{ syntax_block | safe }}
</head>
<body class="md2html-body">
  {% set current_segments = site.get('current_segments', []) | list %}
  {% set navigation = site.get('navigation', []) %}
  {% set navigation_label = site.get('navigation_label', '文档') %}
  {% set outline_label = site.get('outline_label', '大纲') %}
  {% set base_url = (site.get('base_url') or '').rstrip('/') %}
  {% macro nav_href(url) -%}
    {%- if base_url -%}{{ base_url }}/{{ url }}{%- else -%}/{{ url }}{%- endif -%}
  {%- endmacro %}
  {% macro render_nav(nodes, current_segments, parent_key=None) -%}
    {%- for node in nodes %}
      {% set depth = node.segments | length %}
      {% set is_active = current_segments == node.segments %}
      {% set is_expanded = current_segments[:depth] == node.segments %}
  {% set node_key = node.url or (node.segments | join('/')) or (node.title | replace(' ', '-') | lower) %}
  {% set child_id = ('nav-' ~ node_key) | replace('/', '-') | replace('.', '-') %}
      <div class="md2html-nav__item{% if is_active %} md2html-nav__item--active{% endif %}{% if is_expanded %} md2html-nav__item--expanded{% endif %}"
        data-nav-node="{{ node_key }}"
        {% if parent_key %}data-nav-parent="{{ parent_key }}"{% endif %}>
        <div class="md2html-nav__entry{% if not node.children %} md2html-nav__entry--leaf{% endif %}">
          {% if node.children %}
          <button type="button"
            class="md2html-nav__toggle"
            data-nav-toggle="{{ node_key }}"
            data-expanded="{% if is_expanded %}true{% else %}false{% endif %}"
            {% if is_expanded %}data-initial-expanded="true"{% endif %}
              {% if is_expanded %}aria-expanded="true"{% else %}aria-expanded="false"{% endif %}
            aria-label="切换 {{ node.title }} 子目录">
            <span class="md2html-nav__toggle-icon" aria-hidden="true"></span>
          </button>
          {% endif %}
          {% if node.url %}
          <a class="md2html-nav__link" href="{{ nav_href(node.url) }}" data-nav-title="{{ node.title }}">{{ node.title }}</a>
          {% else %}
          <span class="md2html-nav__text" data-nav-title="{{ node.title }}">{{ node.title }}</span>
          {% endif %}
        </div>
        {% if node.children %}
  <div class="md2html-nav__list" id="{{ child_id }}">
          {{ render_nav(node.children, current_segments, node_key) }}
        </div>
        {% endif %}
      </div>
    {%- endfor %}
  {%- endmacro %}
  <div class="md2html-layout{% if not toc %} md2html-layout--no-outline{% endif %}">
  <aside class="md2html-sidebar" aria-label="{{ navigation_label }}">
      <div class="md2html-sidebar__brand">
        <span class="md2html-sidebar__brand-title">{{ site.title or metadata.title or '文档' }}</span>
        {% if site.description %}
        <span class="md2html-sidebar__brand-description">{{ site.description }}</span>
        {% endif %}
      </div>
      {% if navigation %}
      <nav class="md2html-sidebar__nav" aria-label="{{ navigation_label }}">
        <div class="md2html-sidebar__header">
          <div class="md2html-sidebar__section-title">{{ navigation_label }}</div>
          <div class="md2html-sidebar__search">
            <input type="search" class="md2html-sidebar__search-input" placeholder="搜索章节" aria-label="搜索章节" data-md2html-nav-search />
          </div>
        </div>
        <div class="md2html-nav" data-md2html-nav>
          {{ render_nav(navigation, current_segments) }}
        </div>
        <div class="md2html-nav__empty is-hidden" data-md2html-nav-empty>未找到匹配目录</div>
      </nav>
      {% endif %}
    </aside>
  <main class="md2html-main">
      <header class="md2html-header">
        <div class="md2html-header__inner">
          <div class="md2html-header__text">
            <div class="md2html-header__title">{{ metadata.title or site.title or '文档' }}</div>
            {% if metadata.description or site.description %}
            <p class="md2html-header__description">{{ metadata.description or site.description }}</p>
            {% endif %}
          </div>
          <div class="md2html-header__actions" aria-label="界面控制">
            {% if navigation %}
            <button type="button" class="md2html-action-button md2html-action-button--mobile" data-action="open-drawer" data-target="navigation" title="打开{{ navigation_label }}" aria-label="打开{{ navigation_label }}">
              <span class="md2html-action-button__icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false">
                  <path d="M4 6.5h16a1 1 0 1 0 0-2H4a1 1 0 0 0 0 2Zm16 5H4a1 1 0 0 0 0 2h16a1 1 0 1 0 0-2Zm0 7H4a1 1 0 0 0 0 2h16a1 1 0 1 0 0-2Z"/>
                </svg>
              </span>
            </button>
            {% endif %}
            {% if toc %}
            <button type="button" class="md2html-action-button md2html-action-button--mobile" data-action="open-drawer" data-target="outline" title="打开{{ outline_label }}" aria-label="打开{{ outline_label }}">
              <span class="md2html-action-button__icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false">
                  <path d="M5 6a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm0 12a2 2 0 1 1 4 0 2 2 0 0 1-4 0ZM7 11a2 2 0 1 0-2 2 2 2 0 0 0 2-2Zm5-5.5a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2h-6a1 1 0 0 1-1-1Zm1 5a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2h-6a1 1 0 0 1-1-1Zm1 6a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2h-6a1 1 0 0 1-1-1Z"/>
                </svg>
              </span>
            </button>
            {% endif %}
            <button type="button" class="md2html-action-button" data-action="toggle-theme" data-state="light" aria-pressed="false" title="切换黑白模式">
              <span class="md2html-action-button__icon md2html-action-button__icon--sun" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false">
                  <path d="M12 4.5a1 1 0 0 1-1-1V2a1 1 0 1 1 2 0v1.5a1 1 0 0 1-1 1Zm0 17a1 1 0 0 1-1-1V19a1 1 0 1 1 2 0v1.5a1 1 0 0 1-1 1Zm7.5-7.5a1 1 0 0 1-1 1H17a1 1 0 1 1 0-2h1.5a1 1 0 0 1 1 1Zm-14 0a1 1 0 0 1-1 1H3a1 1 0 1 1 0-2h1.5a1 1 0 0 1 1 1Zm10.61-6.61a1 1 0 0 1 0-1.41l1.06-1.06a1 1 0 1 1 1.41 1.41L17.5 7.39a1 1 0 0 1-1.41 0Zm-9.22 9.22a1 1 0 0 1 0-1.41L6.94 11.64a1 1 0 0 1 1.41 1.41L7.39 14.7a1 1 0 0 1-1.41 0Zm9.22 0 1.06 1.06a1 1 0 0 1-1.41 1.41L14.7 17.5a1 1 0 0 1 1.41-1.41Zm-9.22-9.22L7.39 6.94A1 1 0 1 1 5.98 5.53L4.92 6.59A1 1 0 0 1 6.33 8ZM12 8a4 4 0 1 1 0 8 4 4 0 0 1 0-8Z"/>
                </svg>
              </span>
              <span class="md2html-action-button__icon md2html-action-button__icon--moon" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false">
                  <path d="M21 12.79a9 9 0 0 1-11.79 8.53 1 1 0 0 1-.21-1.8A7 7 0 0 0 13.48 4a1 1 0 0 1 .86-1.49A9 9 0 0 1 21 12.79Z"/>
                </svg>
              </span>
            </button>
            <button type="button" class="md2html-action-button" data-action="toggle-expand" data-state="collapsed" aria-pressed="false" title="展开或折叠隐藏内容">
              <span class="md2html-action-button__icon md2html-action-button__icon--expand" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false">
                  <path d="M6 9a1 1 0 0 1 .48-1.34l5-2a1 1 0 0 1 .9 0l5 2A1 1 0 0 1 18 9v6a1 1 0 0 1-.62.92l-5 2a1 1 0 0 1-.76 0l-5-2A1 1 0 0 1 6 15Zm2 .62v4.57L12 16l4-1.81V9.62L12 8Z"/>
                </svg>
              </span>
              <span class="md2html-action-button__icon md2html-action-button__icon--collapse" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false">
                  <path d="M6 9a1 1 0 0 1 .7-.95l5-1.67a1 1 0 0 1 .6 0l5 1.67A1 1 0 0 1 18 9v6a1 1 0 0 1-.7.95l-5 1.67a1 1 0 0 1-.6 0l-5-1.67A1 1 0 0 1 6 15Zm2 .62v4.08L12 16l4-1.3V9.62L12 8.38Z"/>
                </svg>
              </span>
            </button>
          </div>
        </div>
      </header>
      {% if navigation %}
  <div class="md2html-drawer" data-drawer="navigation" aria-hidden="true">
        <button type="button" class="md2html-drawer__backdrop" data-drawer-dismiss aria-label="关闭{{ navigation_label }}"></button>
        <aside class="md2html-drawer__panel" aria-label="{{ navigation_label }}">
          <div class="md2html-drawer__header">
            <span class="md2html-drawer__title">{{ navigation_label }}</span>
            <button type="button" class="md2html-drawer__close" data-drawer-dismiss aria-label="关闭{{ navigation_label }}">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="md2html-drawer__body">
            <nav class="md2html-drawer__section" aria-label="{{ navigation_label }}">
              <div class="md2html-sidebar__search">
                <input type="search" class="md2html-sidebar__search-input" placeholder="搜索章节" aria-label="搜索章节" data-md2html-nav-search />
              </div>
              <div class="md2html-nav" data-md2html-nav>
                {{ render_nav(navigation, current_segments) }}
              </div>
              <div class="md2html-nav__empty is-hidden" data-md2html-nav-empty>未找到匹配目录</div>
            </nav>
          </div>
        </aside>
      </div>
      {% endif %}
      {% if toc %}
  <div class="md2html-drawer" data-drawer="outline" aria-hidden="true">
        <button type="button" class="md2html-drawer__backdrop" data-drawer-dismiss aria-label="关闭{{ outline_label }}"></button>
        <aside class="md2html-drawer__panel md2html-drawer__panel--right" aria-label="{{ outline_label }}">
          <div class="md2html-drawer__header">
            <span class="md2html-drawer__title">{{ outline_label }}</span>
            <button type="button" class="md2html-drawer__close" data-drawer-dismiss aria-label="关闭{{ outline_label }}">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="md2html-drawer__body">
            <div class="md2html-outline__search">
              <input type="search" class="md2html-outline__search-input" placeholder="搜索标题" aria-label="搜索标题" data-md2html-toc-search />
            </div>
            <div class="md2html-toc" data-md2html-toc>
              <div class="md2html-toc__list">
                {%- for item in toc %}
                <div class="md2html-toc__item md2html-toc__item--level-{{ item.level }}" data-toc-level="{{ item.level }}" data-toc-slug="{{ item.slug }}">
                  <a href="#{{ item.slug }}">{{ item.title }}</a>
                </div>
                {%- endfor %}
              </div>
              <div class="md2html-toc__empty is-hidden" data-md2html-toc-empty>未找到匹配标题</div>
            </div>
          </div>
        </aside>
      </div>
      {% endif %}
      <article class="md2html-article markdown-body">
        {{ content | safe }}
      </article>
    </main>
    {% if toc %}
    <aside class="md2html-outline" aria-label="{{ outline_label }}">
      <div class="md2html-outline__header">
        <div class="md2html-outline__section-title">{{ outline_label }}</div>
        <div class="md2html-outline__search">
          <input type="search" class="md2html-outline__search-input" placeholder="搜索标题" aria-label="搜索标题" data-md2html-toc-search />
        </div>
      </div>
      <div class="md2html-toc" data-md2html-toc>
        <div class="md2html-toc__list">
          {%- for item in toc %}
          <div class="md2html-toc__item md2html-toc__item--level-{{ item.level }}" data-toc-level="{{ item.level }}" data-toc-slug="{{ item.slug }}">
            <a href="#{{ item.slug }}">{{ item.title }}</a>
          </div>
          {%- endfor %}
        </div>
        <div class="md2html-toc__empty is-hidden" data-md2html-toc-empty>未找到匹配标题</div>
      </div>
    </aside>
    {% endif %}
  </div>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
  <script>
    (function () {
      const root = document.documentElement;
      const themeKey = "md2html-theme";
      const expandKey = "md2html-expand-hidden";
      const navKey = "md2html-nav-expanded";
      const themeButton = document.querySelector('[data-action="toggle-theme"]');
      const expandButton = document.querySelector('[data-action="toggle-expand"]');
      const pageBody = document.body;
      const drawerButtons = document.querySelectorAll('[data-action="open-drawer"]');
      const drawerDismissButtons = document.querySelectorAll('[data-drawer-dismiss]');
      const drawerMap = new Map();
  const actionBar = document.querySelector('.md2html-header__actions');
  const floatingQuery = globalThis.matchMedia ? globalThis.matchMedia('(max-width: 960px)') : null;
      for (const drawer of document.querySelectorAll('[data-drawer]')) {
        const name = drawer.dataset.drawer;
        if (name) {
          drawerMap.set(name, drawer);
        }
      }
  const navContainers = document.querySelectorAll('[data-md2html-nav]');

      const prefersDark = globalThis.matchMedia && globalThis.matchMedia('(prefers-color-scheme: dark)').matches;

      function saveTheme(value) {
        try {
          localStorage.setItem(themeKey, value);
        } catch (err) {
          console.debug('Failed to persist theme preference', err);
        }
      }

      function getStoredTheme() {
        try {
          const value = localStorage.getItem(themeKey);
          return value === 'dark' || value === 'light' ? value : null;
        } catch (err) {
          console.debug('Failed to read theme preference', err);
          return null;
        }
      }

      function applyTheme(mode, persist = true) {
        if (mode === 'dark' || mode === 'light') {
          root.dataset.md2htmlTheme = mode;
          if (persist) {
            saveTheme(mode);
          }
        } else {
          delete root.dataset.md2htmlTheme;
          if (persist) {
            try {
              localStorage.removeItem(themeKey);
            } catch (err) {
              console.debug('Failed to clear theme preference', err);
            }
          }
        }
        updateThemeButton(mode || (prefersDark ? 'dark' : 'light'));
      }

      function updateThemeButton(mode) {
        if (!themeButton) return;
        const isDark = mode === 'dark';
        themeButton.setAttribute('aria-pressed', isDark ? 'true' : 'false');
        themeButton.dataset.state = isDark ? 'dark' : 'light';
      }

      function toggleTheme() {
        const current = root.dataset.md2htmlTheme || getStoredTheme() || (prefersDark ? 'dark' : 'light');
        const next = current === 'dark' ? 'light' : 'dark';
        applyTheme(next);
      }

      function saveExpandPreference(value) {
        try {
          localStorage.setItem(expandKey, value ? 'true' : 'false');
        } catch (err) {
          console.debug('Failed to persist expand preference', err);
        }
      }

      function getExpandPreference() {
        try {
          return localStorage.getItem(expandKey) === 'true';
        } catch (err) {
          console.debug('Failed to read expand preference', err);
          return false;
        }
      }

      function applyExpand(enabled, persist = true) {
        for (const details of document.querySelectorAll('.md2html-hide')) {
          if (!(details instanceof HTMLDetailsElement)) continue;
          if (enabled) {
            details.open = true;
            details.dataset.md2htmlForceOpen = 'true';
          } else if (details.dataset.md2htmlForceOpen === 'true') {
            details.open = false;
            delete details.dataset.md2htmlForceOpen;
          }
        }
        if (expandButton) {
          expandButton.setAttribute('aria-pressed', enabled ? 'true' : 'false');
          expandButton.dataset.state = enabled ? 'expanded' : 'collapsed';
        }
        if (persist) {
          saveExpandPreference(enabled);
        }
      }

      function toggleExpand() {
        const isExpanded = expandButton ? expandButton.dataset.state === 'expanded' : false;
        applyExpand(!isExpanded);
      }

      function createEmptyNavState() {
        return {
          expanded: new Set(),
          collapsed: new Set(),
          legacy: false,
        };
      }

      function loadNavState() {
        try {
          const raw = localStorage.getItem(navKey);
          if (!raw) {
            return createEmptyNavState();
          }
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            return {
              expanded: new Set(parsed.filter(Boolean)),
              collapsed: new Set(),
              legacy: true,
            };
          }
          if (parsed && typeof parsed === 'object') {
            const expanded = Array.isArray(parsed.expanded) ? parsed.expanded.filter(Boolean) : [];
            const collapsed = Array.isArray(parsed.collapsed) ? parsed.collapsed.filter(Boolean) : [];
            return {
              expanded: new Set(expanded),
              collapsed: new Set(collapsed),
              legacy: false,
            };
          }
        } catch (err) {
          console.debug('Failed to read navigation state', err);
        }
        return createEmptyNavState();
      }

      const navState = loadNavState();

      function persistNavState() {
        try {
          localStorage.setItem(
            navKey,
            JSON.stringify({
              expanded: Array.from(navState.expanded),
              collapsed: Array.from(navState.collapsed),
            })
          );
        } catch (err) {
          console.debug('Failed to persist navigation state', err);
        }
      }

      if (navState.legacy) {
        persistNavState();
      }

      let drawerLocksFloating = false;

      function updateDrawerBodyState() {
        let anyOpen = false;
        for (const drawer of drawerMap.values()) {
          if (drawer.classList.contains('md2html-drawer--open')) {
            anyOpen = true;
            break;
          }
        }
        if (pageBody) {
          pageBody.classList.toggle('md2html-body--drawer-open', anyOpen);
        }
        drawerLocksFloating = anyOpen;
        refreshFloatingActions();
      }

      function setDrawerState(name, open) {
        const drawer = drawerMap.get(name);
        if (!drawer) {
          return;
        }
        drawer.classList.toggle('md2html-drawer--open', open);
        drawer.setAttribute('aria-hidden', open ? 'false' : 'true');
        updateDrawerBodyState();
      }

      function closeAllDrawers() {
        for (const name of drawerMap.keys()) {
          setDrawerState(name, false);
        }
      }

      function isFloatingViewport() {
        if (!floatingQuery) {
          return globalThis.innerWidth <= 960;
        }
        return floatingQuery.matches;
      }

      function refreshFloatingActions() {
        if (!actionBar) {
          return;
        }
        if (!isFloatingViewport()) {
          actionBar.classList.remove('md2html-header__actions--floating', 'md2html-header__actions--hidden');
          return;
        }
        const scrollOffset = globalThis.scrollY || root.scrollTop || 0;
        const shouldFloat = scrollOffset > 60 || drawerLocksFloating;
        if (!shouldFloat) {
          actionBar.classList.remove('md2html-header__actions--floating', 'md2html-header__actions--hidden');
          return;
        }
        actionBar.classList.add('md2html-header__actions--floating');
        if (drawerLocksFloating || scrollOffset < 140) {
          actionBar.classList.add('md2html-header__actions--hidden');
        } else {
          actionBar.classList.remove('md2html-header__actions--hidden');
        }
      }

      function navItemHasActiveDescendant(item) {
        return item.classList.contains('md2html-nav__item--active') || Boolean(item.querySelector('.md2html-nav__item--active'));
      }

      function resolveNavExpansion(key, item, toggle) {
        if (navState.collapsed.has(key)) {
          return false;
        }
        if (navState.expanded.has(key)) {
          return true;
        }
        const seeded = Boolean(toggle && toggle.dataset.initialExpanded === 'true');
        return seeded || navItemHasActiveDescendant(item);
      }

      function setToggleState(toggle, expanded) {
        toggle.ariaExpanded = expanded ? 'true' : 'false';
        toggle.dataset.expanded = expanded ? 'true' : 'false';
      }

      function updateNavPreference(key, expanded) {
        if (expanded) {
          navState.expanded.add(key);
          navState.collapsed.delete(key);
        } else {
          navState.collapsed.add(key);
          navState.expanded.delete(key);
        }
        persistNavState();
      }

      function applyNavState() {
        const items = document.querySelectorAll('[data-nav-node]');
        for (const item of items) {
          const key = item.dataset.navNode;
          if (!key) continue;
          const toggle = item.querySelector('[data-nav-toggle]');
          const shouldExpand = resolveNavExpansion(key, item, toggle);
          item.classList.toggle('md2html-nav__item--expanded', shouldExpand);
          if (toggle) {
            setToggleState(toggle, shouldExpand);
            if (toggle.dataset.initialExpanded === 'true') {
              toggle.dataset.initialExpanded = 'false';
            }
          }
        }
      }

      function initNavHandlers() {
        for (const container of navContainers) {
          container.addEventListener('click', function (event) {
            const target = event.target instanceof Element ? event.target : null;
            if (!target) {
              return;
            }
            const toggle = target.closest('[data-nav-toggle]');
            if (!toggle) {
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            const item = toggle.closest('[data-nav-node]');
            const key = toggle.dataset.navToggle;
            if (!item || !key) {
              return;
            }
            const isExpanded = item.classList.contains('md2html-nav__item--expanded');
            const nextState = !isExpanded;
            item.classList.toggle('md2html-nav__item--expanded', nextState);
            setToggleState(toggle, nextState);
            updateNavPreference(key, nextState);
            applyNavState();
          });
        }
      }

      function initDrawerHandlers() {
        for (const button of drawerButtons) {
          button.addEventListener('click', function () {
            const targetName = button.dataset.target;
            if (!targetName) {
              return;
            }
            const drawer = drawerMap.get(targetName);
            const isOpen = drawer ? drawer.classList.contains('md2html-drawer--open') : false;
            if (isOpen) {
              setDrawerState(targetName, false);
            } else {
              closeAllDrawers();
              setDrawerState(targetName, true);
            }
          });
        }

        for (const dismiss of drawerDismissButtons) {
          dismiss.addEventListener('click', function () {
            const parentDrawer = dismiss.closest('[data-drawer]');
            if (!parentDrawer) {
              return;
            }
            const targetName = parentDrawer.dataset.drawer;
            if (!targetName) {
              return;
            }
            setDrawerState(targetName, false);
          });
        }

        for (const link of document.querySelectorAll('[data-drawer] .md2html-nav__link, [data-drawer] .md2html-toc a')) {
          link.addEventListener('click', function () {
            closeAllDrawers();
          });
        }

        document.addEventListener('keydown', function (event) {
          if (event.key === 'Escape') {
            for (const drawer of drawerMap.values()) {
              if (drawer.classList.contains('md2html-drawer--open')) {
                event.preventDefault();
                closeAllDrawers();
                break;
              }
            }
          }
        });
      }

      function initFloatingObservers() {
        globalThis.addEventListener('scroll', refreshFloatingActions, { passive: true });
        globalThis.addEventListener('resize', refreshFloatingActions);
        if (!floatingQuery) {
          return;
        }
        const mqHandler = function () {
          refreshFloatingActions();
        };
        if (typeof floatingQuery.addEventListener === 'function') {
          floatingQuery.addEventListener('change', mqHandler);
        } else if (typeof floatingQuery.addListener === 'function') {
          floatingQuery.addListener(mqHandler);
        }
      }

      const htmlEscaper = document.createElement('div');

      function escapeHtml(value) {
        htmlEscaper.textContent = value == null ? '' : String(value);
        return htmlEscaper.innerHTML;
      }

      function highlightMatch(text, ranges) {
        if (!ranges || !ranges.length) {
          return escapeHtml(text);
        }
        let cursor = 0;
        let output = '';
        for (const [start, end] of ranges) {
          if (start > cursor) {
            output += escapeHtml(text.slice(cursor, start));
          }
          output += '<mark>' + escapeHtml(text.slice(start, end + 1)) + '</mark>';
          cursor = end + 1;
        }
        if (cursor < text.length) {
          output += escapeHtml(text.slice(cursor));
        }
        return output;
      }

      function createFuseInstance(entries, key) {
        if (typeof Fuse !== 'function') {
          return null;
        }
        return new Fuse(entries, {
          keys: [key],
          includeMatches: true,
          threshold: 0.3,
          ignoreLocation: true,
          minMatchCharLength: 1,
        });
      }

      function buildMatchMap(entries, matches, hasQuery, getKey) {
        const map = new Map();
        if (hasQuery) {
          for (const match of matches) {
            const key = getKey(match.item);
            if (key != null) {
              map.set(key, match.matches && match.matches[0]);
            }
          }
          return map;
        }
        for (const entry of entries) {
          const key = getKey(entry);
          if (key != null) {
            map.set(key, null);
          }
        }
        return map;
      }

      function syncSearchInputs(inputs, source, value) {
        for (const input of inputs) {
          if (input !== source) {
            input.value = value;
          }
        }
      }

      function updateNavEmptyState(hasResults) {
        const placeholders = document.querySelectorAll('[data-md2html-nav-empty]');
        for (const node of placeholders) {
          node.classList.toggle('is-hidden', hasResults);
        }
      }

      function ensureNavEntry(index, entries, key) {
        let entry = index.get(key);
        if (!entry) {
          entry = {
            key,
            title: '',
            parentKey: null,
            elements: [],
            labels: [],
            children: new Set(),
          };
          index.set(key, entry);
          entries.push(entry);
        }
        return entry;
      }

      function hydrateNavEntry(item, index, entries) {
        const key = item.dataset.navNode;
        if (!key) {
          return;
        }
        const entry = ensureNavEntry(index, entries, key);
        const parentKey = item.dataset.navParent || '';
        if (parentKey && !entry.parentKey) {
          entry.parentKey = parentKey;
        }
        const label = item.querySelector('[data-nav-title]');
        if (label) {
          if (!label.dataset.originalText) {
            label.dataset.originalText = label.textContent || '';
          }
          if (!entry.title && label.dataset.originalText) {
            entry.title = label.dataset.originalText;
          }
          entry.labels.push(label);
        }
        entry.elements.push(item);
      }

      function linkNavParents(index) {
        for (const entry of index.values()) {
          if (entry.parentKey && index.has(entry.parentKey)) {
            const parent = index.get(entry.parentKey);
            parent.children.add(entry.key);
          }
        }
      }

      function collectNavEntries(containers) {
        const index = new Map();
        const entries = [];
        for (const container of containers) {
          const items = container.querySelectorAll('[data-nav-node]');
          for (const item of items) {
            hydrateNavEntry(item, index, entries);
          }
        }
        linkNavParents(index);
        return { entries, entryMap: index };
      }

      function applyMatchToLabel(label, matchInfo, hasQuery) {
        const original = label.dataset.originalText || '';
        if (!hasQuery || !matchInfo || !matchInfo.indices) {
          label.innerHTML = escapeHtml(original);
          return;
        }
        label.innerHTML = highlightMatch(original, matchInfo.indices);
      }

      function addNavAncestors(key, entryMap, visible) {
        let current = key;
        while (current && !visible.has(current)) {
          visible.add(current);
          const entry = entryMap.get(current);
          current = entry && entry.parentKey ? entry.parentKey : null;
        }
      }

      function addNavDescendants(key, entryMap, visible) {
        const entry = entryMap.get(key);
        if (!entry) {
          return;
        }
        for (const child of entry.children) {
          if (!visible.has(child)) {
            visible.add(child);
            addNavDescendants(child, entryMap, visible);
          }
        }
      }

      function collectNavVisibleKeys(matchMap, entryMap, hasQuery) {
        if (!hasQuery) {
          return new Set(entryMap.keys());
        }
        const visible = new Set();
        for (const key of matchMap.keys()) {
          addNavAncestors(key, entryMap, visible);
          addNavDescendants(key, entryMap, visible);
        }
        return visible;
      }

      function manageSearchExpansion(element, toggle, shouldExpand) {
        if (shouldExpand) {
          if (!element.classList.contains('md2html-nav__item--expanded')) {
            element.dataset.navSearchExpanded = 'true';
            element.classList.add('md2html-nav__item--expanded');
            if (toggle) {
              setToggleState(toggle, true);
            }
          }
          return;
        }
        if (element.dataset.navSearchExpanded) {
          delete element.dataset.navSearchExpanded;
          element.classList.remove('md2html-nav__item--expanded');
          if (toggle) {
            setToggleState(toggle, element.classList.contains('md2html-nav__item--expanded'));
          }
        }
      }

      function resetNavElementFromSearch(element, toggle) {
        element.classList.remove('md2html-nav__item--search-hidden');
        manageSearchExpansion(element, toggle, false);
      }

      function applyNavMatches(entryMap, matchMap, hasQuery) {
        const visibleKeys = collectNavVisibleKeys(matchMap, entryMap, hasQuery);
        for (const [key, entry] of entryMap.entries()) {
          const matchInfo = matchMap.get(key) || null;
          const isVisible = visibleKeys.has(key);
          const hasChildren = entry.children.size > 0;
          for (const element of entry.elements) {
            const toggle = element.querySelector('[data-nav-toggle]');
            if (hasQuery) {
              element.classList.toggle('md2html-nav__item--search-hidden', !isVisible);
              manageSearchExpansion(element, toggle, isVisible && hasChildren);
            } else {
              resetNavElementFromSearch(element, toggle);
            }
          }
          for (const label of entry.labels) {
            applyMatchToLabel(label, matchInfo, hasQuery);
          }
        }
        return visibleKeys.size;
      }

      function collectTocEntries(containers) {
        const entryMap = new Map();
        const entries = [];
        for (const container of containers) {
          const items = container.querySelectorAll('.md2html-toc__item[data-toc-slug]');
          for (const item of items) {
            const slug = item.dataset.tocSlug;
            const link = item.querySelector('a');
            if (!slug || !link) {
              continue;
            }
            if (!link.dataset.originalText) {
              link.dataset.originalText = link.textContent || '';
            }
            const level = Number.parseInt(item.dataset.tocLevel || '1', 10) || 1;
            let entry = entryMap.get(slug);
            if (!entry) {
              entry = { slug, title: link.dataset.originalText, level, elements: [] };
              entryMap.set(slug, entry);
              entries.push(entry);
            }
            entry.elements.push(item);
          }
        }
        return { entries, entryMap };
      }

      function updateTocEmptyState(hasResults) {
        const placeholders = document.querySelectorAll('[data-md2html-toc-empty]');
        for (const node of placeholders) {
          node.classList.toggle('is-hidden', hasResults);
        }
      }

      function applyMatchToLink(link, matchInfo, hasQuery) {
        const original = link.dataset.originalText || '';
        if (!hasQuery || !matchInfo || !matchInfo.indices) {
          link.innerHTML = escapeHtml(original);
          return;
        }
        link.innerHTML = highlightMatch(original, matchInfo.indices);
      }

      function applyMatches(entryMap, matchMap, hasQuery) {
        for (const [slug, entry] of entryMap.entries()) {
          const matchInfo = matchMap.get(slug);
          const shouldShow = hasQuery ? Boolean(matchInfo) : true;
          for (const element of entry.elements) {
            element.classList.toggle('md2html-toc__item--hidden', !shouldShow);
            const link = element.querySelector('a');
            if (link) {
              applyMatchToLink(link, matchInfo, hasQuery);
            }
          }
        }
      }

      function initNavSearch() {
        const navContainers = Array.from(document.querySelectorAll('[data-md2html-nav]'));
        if (!navContainers.length) {
          return;
        }

        const { entries, entryMap } = collectNavEntries(navContainers);
        if (!entries.length) {
          return;
        }

        const fuse = createFuseInstance(entries, 'title');
        const searchInputs = Array.from(document.querySelectorAll('[data-md2html-nav-search]'));
        if (!searchInputs.length) {
          return;
        }

        function performSearch(rawQuery) {
          const trimmed = rawQuery.trim();
          const hasQuery = trimmed.length > 0;
          let matches = [];
          if (hasQuery) {
            if (fuse) {
              matches = fuse.search(trimmed);
            } else {
              const lower = trimmed.toLowerCase();
              for (const entry of entries) {
                if (entry.title && entry.title.toLowerCase().includes(lower)) {
                  matches.push({ item: entry, matches: null });
                }
              }
            }
          }

          const matchMap = buildMatchMap(entries, matches, hasQuery, (entry) => entry.key);
          const visibleCount = applyNavMatches(entryMap, matchMap, hasQuery);
          updateNavEmptyState(visibleCount > 0);
          if (!hasQuery) {
            applyNavState();
          }
        }

        for (const input of searchInputs) {
          input.addEventListener('input', () => {
            const value = input.value;
            syncSearchInputs(searchInputs, input, value);
            performSearch(value);
          });
          input.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
              input.value = '';
              syncSearchInputs(searchInputs, input, '');
              performSearch('');
              input.blur();
            }
          });
        }

        performSearch('');
      }

      function initOutlineSearch() {
          const tocContainers = Array.from(document.querySelectorAll('[data-md2html-toc]'));
          if (!tocContainers.length) {
            return;
          }

          const { entries, entryMap } = collectTocEntries(tocContainers);
          if (!entries.length) {
            return;
          }

          const fuse = createFuseInstance(entries, 'title');
          const searchInputs = Array.from(document.querySelectorAll('[data-md2html-toc-search]'));

          function performSearch(rawQuery) {
            const trimmed = rawQuery.trim();
            const hasQuery = trimmed.length > 0;
            let matches = [];
            if (hasQuery) {
              if (fuse) {
                matches = fuse.search(trimmed);
              } else {
                const lower = trimmed.toLowerCase();
                for (const entry of entries) {
                  if (entry.title && entry.title.toLowerCase().includes(lower)) {
                    matches.push({ item: entry, matches: null });
                  }
                }
              }
            }

            const matchMap = buildMatchMap(entries, matches, hasQuery, (entry) => entry.slug);
            applyMatches(entryMap, matchMap, hasQuery);
            updateTocEmptyState(matchMap.size > 0);
          }

          for (const input of searchInputs) {
            input.addEventListener('input', () => {
              const value = input.value;
              syncSearchInputs(searchInputs, input, value);
              performSearch(value);
            });
            input.addEventListener('keydown', (event) => {
              if (event.key === 'Escape') {
                input.value = '';
                syncSearchInputs(searchInputs, input, '');
                performSearch('');
                input.blur();
              }
            });
          }

          performSearch('');
        }

      initNavHandlers();
      initDrawerHandlers();
      initFloatingObservers();
  initNavSearch();
      initOutlineSearch();

      if (themeButton) {
        themeButton.addEventListener('click', toggleTheme);
      }
      if (expandButton) {
        expandButton.addEventListener('click', toggleExpand);
      }

      const storedTheme = getStoredTheme();
      if (storedTheme) {
        applyTheme(storedTheme, false);
      } else {
        updateThemeButton(prefersDark ? 'dark' : 'light');
      }

      closeAllDrawers();
      applyExpand(getExpandPreference(), false);
      applyNavState();
      refreshFloatingActions();
    })();
  </script>
</body>
</html>
